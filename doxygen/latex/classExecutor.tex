\hypertarget{classExecutor}{}\section{Executor Class Reference}
\label{classExecutor}\index{Executor@{Executor}}


{\ttfamily \#include $<$executor.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classExecutor_a5ea6a42d8c97cb71e5720830af349954}{Executor} (std\+::string workspace)
\item 
\hyperlink{classExecutor_a23108c89c4a25e22c927115191c04b26}{$\sim$\+Executor} ()
\item 
void \hyperlink{classExecutor_a45648f4d114834e3f1abac2d3b89c580}{clear\+\_\+array} (const std\+::string \&array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_a4f9429d0df8f4fb4b055ac9a775527b7}{close\+\_\+array} (const Storage\+Manager\+::\+Array\+Descriptor $\ast$ad) const 
\item 
void \hyperlink{classExecutor_a6adf42d9015146cb8cd8d0b7c8911597}{close\+\_\+fragment} (Storage\+Manager\+::\+Fragment\+Descriptor $\ast$fd) const 
\item 
void \hyperlink{classExecutor_adb431db3659ae76d9d308fa135b73a5e}{define\+\_\+array} (const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema) const 
\item 
void \hyperlink{classExecutor_a5abf0d9cee895dfec60d701c0bc93599}{delete\+\_\+array} (const std\+::string \&array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_af2e63010bb79b43baa8a2cbe60dfd961}{export\+\_\+to\+\_\+csv} (const std\+::string \&array\+\_\+name, const std\+::string \&filename) const 
\item 
bool \hyperlink{classExecutor_a1c0486a017c19e392e2a14f4050374f5}{file\+\_\+exists} (const std\+::string \&filename) const 
\item 
void \hyperlink{classExecutor_a164b2b522121abae3a0adc5da5e035f3}{filter} (const std\+::string \&array\+\_\+name, const std\+::string \&expression, const std\+::string \&result\+\_\+array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_a6867550d21cbde880c10f114f3920f79}{join} (const std\+::string \&array\+\_\+name\+\_\+\+A, const std\+::string \&array\+\_\+name\+\_\+\+B, const std\+::string \&result\+\_\+array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_ac34a362db8c55b14a6b71424f18467d2}{load} (const std\+::string \&filename, const std\+::string \&array\+\_\+name) const 
\item 
const \hyperlink{classArraySchema}{Array\+Schema} $\ast$ \hyperlink{classExecutor_a0cda8766b3b5d866816b30d85a6b138f}{load\+\_\+array\+\_\+schema} (const std\+::string \&array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_ad3f20edeb99f4e8fbd8e78a05293d17f}{nearest\+\_\+neighbors} (const std\+::string \&array\+\_\+name, const std\+::vector$<$ double $>$ \&q, int64\+\_\+t k, const std\+::string \&result\+\_\+array\+\_\+name) const 
\item 
const Storage\+Manager\+::\+Array\+Descriptor $\ast$ \hyperlink{classExecutor_a905abc2da523e6a765c80739c1e64eaf}{open\+\_\+array} (const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema) const 
\item 
Storage\+Manager\+::\+Fragment\+Descriptor $\ast$ \hyperlink{classExecutor_ab72b90048461a0a224ddc704e0aa23bd}{open\+\_\+fragment} (const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema) const 
\item 
void \hyperlink{classExecutor_a85565a2aa21cfd832bf5f8ad0be7026a}{read} (const Storage\+Manager\+::\+Array\+Descriptor $\ast$ad, int attribute\+\_\+id, const void $\ast$range, void $\ast$\&coords, size\+\_\+t \&coords\+\_\+size, void $\ast$\&attrs, size\+\_\+t \&attrs\+\_\+size) const 
\item 
void \hyperlink{classExecutor_ac7406e279c2fbdd1f6b4a8c1e9aeed61}{retile} (const std\+::string \&array\+\_\+name, int64\+\_\+t capacity, \hyperlink{classArraySchema_a847601130253f905337b5e284e1b78f2}{Array\+Schema\+::\+Cell\+Order} cell\+\_\+order, const std\+::vector$<$ double $>$ \&tile\+\_\+extents) const 
\item 
void \hyperlink{classExecutor_a6b14f1a0748cc2950eb300b45419f6b6}{subarray} (const std\+::string \&array\+\_\+name, const double $\ast$range, const std\+::string \&result\+\_\+array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_adae147e4a5668cdfbcefecccdae19334}{update} (const std\+::string \&filename, const std\+::string \&array\+\_\+name) const 
\item 
void \hyperlink{classExecutor_ad4a7f583b63cebbe2a4b056562006633}{write} (Storage\+Manager\+::\+Fragment\+Descriptor $\ast$fd, void $\ast$coords, size\+\_\+t coords\+\_\+size, void $\ast$attrs, size\+\_\+t attrs\+\_\+size) const 
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{classExecutor_ace6488bc7140a974f82232c50469d590}{get\+\_\+all\+\_\+fragment\+\_\+names} (const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema) const 
\item 
bool \hyperlink{classExecutor_a0af6b19b60d913bdb5eb2038640a0004}{path\+\_\+exists} (const std\+::string \&path) const 
\item 
void \hyperlink{classExecutor_a3a3e2b0b4be9e268745001efc43ffbd4}{set\+\_\+workspace} (const std\+::string \&path)
\item 
void \hyperlink{classExecutor_a47f3c192d8031a94b256829aaf09b867}{update\+\_\+fragment\+\_\+info} (const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classConsolidator}{Consolidator} $\ast$ \hyperlink{classExecutor_aa9659d47bccbe09cdd01357712bca7e2}{consolidator\+\_\+}
\item 
\hyperlink{classLoader}{Loader} $\ast$ \hyperlink{classExecutor_a4939f1b29639e263d50da6436c24bff6}{loader\+\_\+}
\item 
\hyperlink{classQueryProcessor}{Query\+Processor} $\ast$ \hyperlink{classExecutor_a83f7004773177d4dd47ca0a3f32d4f89}{query\+\_\+processor\+\_\+}
\item 
\hyperlink{classStorageManager}{Storage\+Manager} $\ast$ \hyperlink{classExecutor_ae8cbe36555c96a8d5efde76a542acd92}{storage\+\_\+manager\+\_\+}
\item 
std\+::string \hyperlink{classExecutor_a6acb7687ad0865b90cb77f3290482d8b}{workspace\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The \hyperlink{classExecutor}{Executor} is responsible for receiving the user queries and dispatching them to the appropriate modules (e.\+g., the \hyperlink{classLoader}{Loader}, the \hyperlink{classConsolidator}{Consolidator}, and the \hyperlink{classQueryProcessor}{Query\+Processor}). 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classExecutor_a5ea6a42d8c97cb71e5720830af349954}{}\index{Executor@{Executor}!Executor@{Executor}}
\index{Executor@{Executor}!Executor@{Executor}}
\subsubsection[{Executor}]{\setlength{\rightskip}{0pt plus 5cm}Executor\+::\+Executor (
\begin{DoxyParamCaption}
\item[{std\+::string}]{workspace}
\end{DoxyParamCaption}
)}\label{classExecutor_a5ea6a42d8c97cb71e5720830af349954}
Simple constructor. \hypertarget{classExecutor_a23108c89c4a25e22c927115191c04b26}{}\index{Executor@{Executor}!````~Executor@{$\sim$\+Executor}}
\index{````~Executor@{$\sim$\+Executor}!Executor@{Executor}}
\subsubsection[{$\sim$\+Executor}]{\setlength{\rightskip}{0pt plus 5cm}Executor\+::$\sim$\+Executor (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classExecutor_a23108c89c4a25e22c927115191c04b26}
The destructor deletes all the created modules. 

\subsection{Member Function Documentation}
\hypertarget{classExecutor_a45648f4d114834e3f1abac2d3b89c580}{}\index{Executor@{Executor}!clear\+\_\+array@{clear\+\_\+array}}
\index{clear\+\_\+array@{clear\+\_\+array}!Executor@{Executor}}
\subsubsection[{clear\+\_\+array}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::clear\+\_\+array (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_a45648f4d114834e3f1abac2d3b89c580}
Deletes all the fragments of the array. \hypertarget{classExecutor_a4f9429d0df8f4fb4b055ac9a775527b7}{}\index{Executor@{Executor}!close\+\_\+array@{close\+\_\+array}}
\index{close\+\_\+array@{close\+\_\+array}!Executor@{Executor}}
\subsubsection[{close\+\_\+array}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::close\+\_\+array (
\begin{DoxyParamCaption}
\item[{const Storage\+Manager\+::\+Array\+Descriptor $\ast$}]{ad}
\end{DoxyParamCaption}
) const}\label{classExecutor_a4f9429d0df8f4fb4b055ac9a775527b7}
Closes an array. \hypertarget{classExecutor_a6adf42d9015146cb8cd8d0b7c8911597}{}\index{Executor@{Executor}!close\+\_\+fragment@{close\+\_\+fragment}}
\index{close\+\_\+fragment@{close\+\_\+fragment}!Executor@{Executor}}
\subsubsection[{close\+\_\+fragment}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::close\+\_\+fragment (
\begin{DoxyParamCaption}
\item[{Storage\+Manager\+::\+Fragment\+Descriptor $\ast$}]{fd}
\end{DoxyParamCaption}
) const}\label{classExecutor_a6adf42d9015146cb8cd8d0b7c8911597}
Closes a fragment. \hypertarget{classExecutor_adb431db3659ae76d9d308fa135b73a5e}{}\index{Executor@{Executor}!define\+\_\+array@{define\+\_\+array}}
\index{define\+\_\+array@{define\+\_\+array}!Executor@{Executor}}
\subsubsection[{define\+\_\+array}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::define\+\_\+array (
\begin{DoxyParamCaption}
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema}
\end{DoxyParamCaption}
) const}\label{classExecutor_adb431db3659ae76d9d308fa135b73a5e}
Defines an array (stores its array schema at the storage manager. \hypertarget{classExecutor_a5abf0d9cee895dfec60d701c0bc93599}{}\index{Executor@{Executor}!delete\+\_\+array@{delete\+\_\+array}}
\index{delete\+\_\+array@{delete\+\_\+array}!Executor@{Executor}}
\subsubsection[{delete\+\_\+array}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::delete\+\_\+array (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_a5abf0d9cee895dfec60d701c0bc93599}
Deletes an array. \hypertarget{classExecutor_af2e63010bb79b43baa8a2cbe60dfd961}{}\index{Executor@{Executor}!export\+\_\+to\+\_\+csv@{export\+\_\+to\+\_\+csv}}
\index{export\+\_\+to\+\_\+csv@{export\+\_\+to\+\_\+csv}!Executor@{Executor}}
\subsubsection[{export\+\_\+to\+\_\+csv}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::export\+\_\+to\+\_\+csv (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{const std\+::string \&}]{filename}
\end{DoxyParamCaption}
) const}\label{classExecutor_af2e63010bb79b43baa8a2cbe60dfd961}
Exports an array to a C\+S\+V file. Each line in the C\+S\+V file represents a logical cell comprised of coordinates and attribute values. The coordinates are written first, and then the attribute values, following the order as defined in the schema of the array. \hypertarget{classExecutor_a1c0486a017c19e392e2a14f4050374f5}{}\index{Executor@{Executor}!file\+\_\+exists@{file\+\_\+exists}}
\index{file\+\_\+exists@{file\+\_\+exists}!Executor@{Executor}}
\subsubsection[{file\+\_\+exists}]{\setlength{\rightskip}{0pt plus 5cm}bool Executor\+::file\+\_\+exists (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename}
\end{DoxyParamCaption}
) const}\label{classExecutor_a1c0486a017c19e392e2a14f4050374f5}
Returns true if the input file exists. \hypertarget{classExecutor_a164b2b522121abae3a0adc5da5e035f3}{}\index{Executor@{Executor}!filter@{filter}}
\index{filter@{filter}!Executor@{Executor}}
\subsubsection[{filter}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::filter (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{const std\+::string \&}]{expression, }
\item[{const std\+::string \&}]{result\+\_\+array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_a164b2b522121abae3a0adc5da5e035f3}
A filter query creates a new array from the input array, containing only the cells whose attribute values satisfy the input expression. The new array will have the input result name. \hypertarget{classExecutor_ace6488bc7140a974f82232c50469d590}{}\index{Executor@{Executor}!get\+\_\+all\+\_\+fragment\+\_\+names@{get\+\_\+all\+\_\+fragment\+\_\+names}}
\index{get\+\_\+all\+\_\+fragment\+\_\+names@{get\+\_\+all\+\_\+fragment\+\_\+names}!Executor@{Executor}}
\subsubsection[{get\+\_\+all\+\_\+fragment\+\_\+names}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$std\+::string$>$ Executor\+::get\+\_\+all\+\_\+fragment\+\_\+names (
\begin{DoxyParamCaption}
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_ace6488bc7140a974f82232c50469d590}
Returns the names of all fragments in the array. \hypertarget{classExecutor_a6867550d21cbde880c10f114f3920f79}{}\index{Executor@{Executor}!join@{join}}
\index{join@{join}!Executor@{Executor}}
\subsubsection[{join}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::join (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name\+\_\+\+A, }
\item[{const std\+::string \&}]{array\+\_\+name\+\_\+\+B, }
\item[{const std\+::string \&}]{result\+\_\+array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_a6867550d21cbde880c10f114f3920f79}
Joins the two input arrays (say, A and B). The result contains a cell only if both the corresponding cells in A and B are non-\/empty. The input arrays must be join-\/compatible (see \hyperlink{classArraySchema_a07cd6246c8275fbaa0e11adad15dd63a}{Array\+Schema\+::join\+\_\+compatible}). Moreover, see \hyperlink{classArraySchema_a043a7a6b37d93748b8acd90f4eebb579}{Array\+Schema\+::create\+\_\+join\+\_\+result\+\_\+schema} to see the schema of the output array. \hypertarget{classExecutor_ac34a362db8c55b14a6b71424f18467d2}{}\index{Executor@{Executor}!load@{load}}
\index{load@{load}!Executor@{Executor}}
\subsubsection[{load}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::load (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename, }
\item[{const std\+::string \&}]{array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_ac34a362db8c55b14a6b71424f18467d2}
Loads a C\+S\+V file into an array. \hypertarget{classExecutor_a0cda8766b3b5d866816b30d85a6b138f}{}\index{Executor@{Executor}!load\+\_\+array\+\_\+schema@{load\+\_\+array\+\_\+schema}}
\index{load\+\_\+array\+\_\+schema@{load\+\_\+array\+\_\+schema}!Executor@{Executor}}
\subsubsection[{load\+\_\+array\+\_\+schema}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Array\+Schema}$\ast$ Executor\+::load\+\_\+array\+\_\+schema (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_a0cda8766b3b5d866816b30d85a6b138f}
Returns an array schema. \hypertarget{classExecutor_ad3f20edeb99f4e8fbd8e78a05293d17f}{}\index{Executor@{Executor}!nearest\+\_\+neighbors@{nearest\+\_\+neighbors}}
\index{nearest\+\_\+neighbors@{nearest\+\_\+neighbors}!Executor@{Executor}}
\subsubsection[{nearest\+\_\+neighbors}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::nearest\+\_\+neighbors (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{const std\+::vector$<$ double $>$ \&}]{q, }
\item[{int64\+\_\+t}]{k, }
\item[{const std\+::string \&}]{result\+\_\+array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_ad3f20edeb99f4e8fbd8e78a05293d17f}
Returns the k nearest neighbors from query point q. The results (along with all their attribute values) are stored in a new array. The distance metric used to calculate proximity is the Euclidean distance. \hypertarget{classExecutor_a905abc2da523e6a765c80739c1e64eaf}{}\index{Executor@{Executor}!open\+\_\+array@{open\+\_\+array}}
\index{open\+\_\+array@{open\+\_\+array}!Executor@{Executor}}
\subsubsection[{open\+\_\+array}]{\setlength{\rightskip}{0pt plus 5cm}const Storage\+Manager\+::\+Array\+Descriptor$\ast$ Executor\+::open\+\_\+array (
\begin{DoxyParamCaption}
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema}
\end{DoxyParamCaption}
) const}\label{classExecutor_a905abc2da523e6a765c80739c1e64eaf}
Opens an array in R\+E\+A\+D mode and returns the corresponding descriptor. \hypertarget{classExecutor_ab72b90048461a0a224ddc704e0aa23bd}{}\index{Executor@{Executor}!open\+\_\+fragment@{open\+\_\+fragment}}
\index{open\+\_\+fragment@{open\+\_\+fragment}!Executor@{Executor}}
\subsubsection[{open\+\_\+fragment}]{\setlength{\rightskip}{0pt plus 5cm}Storage\+Manager\+::\+Fragment\+Descriptor$\ast$ Executor\+::open\+\_\+fragment (
\begin{DoxyParamCaption}
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema}
\end{DoxyParamCaption}
) const}\label{classExecutor_ab72b90048461a0a224ddc704e0aa23bd}
Opens an array fragment in W\+R\+I\+T\+E mode and returns the corresponding descriptor. \hypertarget{classExecutor_a0af6b19b60d913bdb5eb2038640a0004}{}\index{Executor@{Executor}!path\+\_\+exists@{path\+\_\+exists}}
\index{path\+\_\+exists@{path\+\_\+exists}!Executor@{Executor}}
\subsubsection[{path\+\_\+exists}]{\setlength{\rightskip}{0pt plus 5cm}bool Executor\+::path\+\_\+exists (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_a0af6b19b60d913bdb5eb2038640a0004}
Returns true if the input path is an existing directory. \hypertarget{classExecutor_a85565a2aa21cfd832bf5f8ad0be7026a}{}\index{Executor@{Executor}!read@{read}}
\index{read@{read}!Executor@{Executor}}
\subsubsection[{read}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::read (
\begin{DoxyParamCaption}
\item[{const Storage\+Manager\+::\+Array\+Descriptor $\ast$}]{ad, }
\item[{int}]{attribute\+\_\+id, }
\item[{const void $\ast$}]{range, }
\item[{void $\ast$\&}]{coords, }
\item[{size\+\_\+t \&}]{coords\+\_\+size, }
\item[{void $\ast$\&}]{attrs, }
\item[{size\+\_\+t \&}]{attrs\+\_\+size}
\end{DoxyParamCaption}
) const}\label{classExecutor_a85565a2aa21cfd832bf5f8ad0be7026a}
Copies the coordinates of the non-\/empty cells of the input array falling inside the input range into the coords buffer, and their corresponding attribute values on the input attribute into buffer values, setting properly the buffer sizes in bytes. \hypertarget{classExecutor_ac7406e279c2fbdd1f6b4a8c1e9aeed61}{}\index{Executor@{Executor}!retile@{retile}}
\index{retile@{retile}!Executor@{Executor}}
\subsubsection[{retile}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::retile (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{int64\+\_\+t}]{capacity, }
\item[{{\bf Array\+Schema\+::\+Cell\+Order}}]{cell\+\_\+order, }
\item[{const std\+::vector$<$ double $>$ \&}]{tile\+\_\+extents}
\end{DoxyParamCaption}
) const}\label{classExecutor_ac7406e279c2fbdd1f6b4a8c1e9aeed61}
Retiles an array based on the inputs. If tile extents are provided (i) in the case of regular tiles, if the extents differ from those in the array schema, retiling occurs, (ii) in the case of irregular tiles, the array is retiled so that it has regular tiles. If tile extents are not provided for the case of regular tiles, the array is retiled to one with irregular tiles. If order is provided (different from the existing order) retiling occurs. If a capacity is provided, (i) in the case of regular tiles it has no effect (only the schema changes), (ii) in the case of irregular tiles, only the book-\/keeping structures and array schema are altered to accommodate the change. \hypertarget{classExecutor_a3a3e2b0b4be9e268745001efc43ffbd4}{}\index{Executor@{Executor}!set\+\_\+workspace@{set\+\_\+workspace}}
\index{set\+\_\+workspace@{set\+\_\+workspace}!Executor@{Executor}}
\subsubsection[{set\+\_\+workspace}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::set\+\_\+workspace (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_a3a3e2b0b4be9e268745001efc43ffbd4}
Simply sets the workspace. \hypertarget{classExecutor_a6b14f1a0748cc2950eb300b45419f6b6}{}\index{Executor@{Executor}!subarray@{subarray}}
\index{subarray@{subarray}!Executor@{Executor}}
\subsubsection[{subarray}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::subarray (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{const double $\ast$}]{range, }
\item[{const std\+::string \&}]{result\+\_\+array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_a6b14f1a0748cc2950eb300b45419f6b6}
A subarray query creates a new array from the input array, containing only the cells whose coordinates fall into the input range. The new array will have the input result name. \hypertarget{classExecutor_adae147e4a5668cdfbcefecccdae19334}{}\index{Executor@{Executor}!update@{update}}
\index{update@{update}!Executor@{Executor}}
\subsubsection[{update}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::update (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename, }
\item[{const std\+::string \&}]{array\+\_\+name}
\end{DoxyParamCaption}
) const}\label{classExecutor_adae147e4a5668cdfbcefecccdae19334}
Updates an array with the data in the input C\+S\+V file. \hypertarget{classExecutor_a47f3c192d8031a94b256829aaf09b867}{}\index{Executor@{Executor}!update\+\_\+fragment\+\_\+info@{update\+\_\+fragment\+\_\+info}}
\index{update\+\_\+fragment\+\_\+info@{update\+\_\+fragment\+\_\+info}!Executor@{Executor}}
\subsubsection[{update\+\_\+fragment\+\_\+info}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::update\+\_\+fragment\+\_\+info (
\begin{DoxyParamCaption}
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_a47f3c192d8031a94b256829aaf09b867}
Updates the fragment information (adding one fragment) of an array. \hypertarget{classExecutor_ad4a7f583b63cebbe2a4b056562006633}{}\index{Executor@{Executor}!write@{write}}
\index{write@{write}!Executor@{Executor}}
\subsubsection[{write}]{\setlength{\rightskip}{0pt plus 5cm}void Executor\+::write (
\begin{DoxyParamCaption}
\item[{Storage\+Manager\+::\+Fragment\+Descriptor $\ast$}]{fd, }
\item[{void $\ast$}]{coords, }
\item[{size\+\_\+t}]{coords\+\_\+size, }
\item[{void $\ast$}]{attrs, }
\item[{size\+\_\+t}]{attrs\+\_\+size}
\end{DoxyParamCaption}
) const}\label{classExecutor_ad4a7f583b63cebbe2a4b056562006633}
Writes the input coordinates and attributess into an array. The input cells do not respect the global cell order. N\+O\+T\+E\+: The input buffers will be freed by the function. 

\subsection{Member Data Documentation}
\hypertarget{classExecutor_aa9659d47bccbe09cdd01357712bca7e2}{}\index{Executor@{Executor}!consolidator\+\_\+@{consolidator\+\_\+}}
\index{consolidator\+\_\+@{consolidator\+\_\+}!Executor@{Executor}}
\subsubsection[{consolidator\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Consolidator}$\ast$ Executor\+::consolidator\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_aa9659d47bccbe09cdd01357712bca7e2}
The \hyperlink{classConsolidator}{Consolidator} module. \hypertarget{classExecutor_a4939f1b29639e263d50da6436c24bff6}{}\index{Executor@{Executor}!loader\+\_\+@{loader\+\_\+}}
\index{loader\+\_\+@{loader\+\_\+}!Executor@{Executor}}
\subsubsection[{loader\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Loader}$\ast$ Executor\+::loader\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_a4939f1b29639e263d50da6436c24bff6}
The \hyperlink{classLoader}{Loader} module. \hypertarget{classExecutor_a83f7004773177d4dd47ca0a3f32d4f89}{}\index{Executor@{Executor}!query\+\_\+processor\+\_\+@{query\+\_\+processor\+\_\+}}
\index{query\+\_\+processor\+\_\+@{query\+\_\+processor\+\_\+}!Executor@{Executor}}
\subsubsection[{query\+\_\+processor\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Query\+Processor}$\ast$ Executor\+::query\+\_\+processor\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_a83f7004773177d4dd47ca0a3f32d4f89}
The \hyperlink{classQueryProcessor}{Query\+Processor} module. \hypertarget{classExecutor_ae8cbe36555c96a8d5efde76a542acd92}{}\index{Executor@{Executor}!storage\+\_\+manager\+\_\+@{storage\+\_\+manager\+\_\+}}
\index{storage\+\_\+manager\+\_\+@{storage\+\_\+manager\+\_\+}!Executor@{Executor}}
\subsubsection[{storage\+\_\+manager\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Storage\+Manager}$\ast$ Executor\+::storage\+\_\+manager\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_ae8cbe36555c96a8d5efde76a542acd92}
The \hyperlink{classStorageManager}{Storage\+Manager} module. \hypertarget{classExecutor_a6acb7687ad0865b90cb77f3290482d8b}{}\index{Executor@{Executor}!workspace\+\_\+@{workspace\+\_\+}}
\index{workspace\+\_\+@{workspace\+\_\+}!Executor@{Executor}}
\subsubsection[{workspace\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string Executor\+::workspace\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classExecutor_a6acb7687ad0865b90cb77f3290482d8b}
A folder in the disk where the \hyperlink{classExecutor}{Executor} creates all its data. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
core/include/\hyperlink{executor_8h}{executor.\+h}\end{DoxyCompactItemize}
