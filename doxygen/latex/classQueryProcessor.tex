\hypertarget{classQueryProcessor}{}\section{Query\+Processor Class Reference}
\label{classQueryProcessor}\index{Query\+Processor@{Query\+Processor}}


{\ttfamily \#include $<$query\+\_\+processor.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classQueryProcessor_a07816ecd785ad36631c525e3babaa6b0}{Query\+Processor} (\hyperlink{classStorageManager}{Storage\+Manager} $\ast$storage\+\_\+manager)
\item 
\hypertarget{classQueryProcessor_a266b9a19078345543700e8654949b1b0}{}int {\bfseries err} () const \label{classQueryProcessor_a266b9a19078345543700e8654949b1b0}

\item 
int \hyperlink{classQueryProcessor_ad30605917457abc19c3e5606fbb6d581}{export\+\_\+csv} (const std\+::string \&array\+\_\+name, const std\+::string \&filename, const std\+::vector$<$ std\+::string $>$ \&dim\+\_\+names, const std\+::vector$<$ std\+::string $>$ \&attribute\+\_\+names, bool reverse) const 
\item 
int \hyperlink{classQueryProcessor_add4b7d3e4e75b226016f385d09001f1e}{subarray} (const std\+::string \&array\+\_\+name, const std\+::vector$<$ double $>$ \&range, const std\+::string \&result\+\_\+array\+\_\+name, const std\+::vector$<$ std\+::string $>$ \&attribute\+\_\+names) const 
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classQueryProcessor_ac47f5cc3f8ab2e025002a1dbcf07e736}{export\+\_\+csv} (int ad, const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema, const std\+::string \&filename, const std\+::vector$<$ int $>$ \&dim\+\_\+ids, const std\+::vector$<$ int $>$ \&attribute\+\_\+ids) const 
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classQueryProcessor_ac490bbe57b408f2b09b96232ff49b88c}{export\+\_\+csv\+\_\+reverse} (int ad, const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema, const std\+::string \&filename, const std\+::vector$<$ int $>$ \&dim\+\_\+ids, const std\+::vector$<$ int $>$ \&attribute\+\_\+ids) const 
\item 
int \hyperlink{classQueryProcessor_a0ca14aca91dfa55c6acb82ed9f2c7e08}{parse\+\_\+attribute\+\_\+names} (const std\+::vector$<$ std\+::string $>$ \&attribute\+\_\+names, const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema, std\+::vector$<$ int $>$ \&attribute\+\_\+ids, std\+::string \&err\+\_\+msg) const 
\item 
int \hyperlink{classQueryProcessor_a9dc7581a12ae6ab63518a372ec1702d8}{parse\+\_\+dim\+\_\+names} (const std\+::vector$<$ std\+::string $>$ \&dim\+\_\+names, const \hyperlink{classArraySchema}{Array\+Schema} $\ast$array\+\_\+schema, std\+::vector$<$ int $>$ \&dim\+\_\+ids, std\+::string \&err\+\_\+msg) const 
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{classQueryProcessor_a382d9d3f7639ba3594877872e0bbcd95}{subarray} (int ad, const T $\ast$range, int result\+\_\+ad, const std\+::vector$<$ int $>$ \&attribute\+\_\+ids) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classStorageManager}{Storage\+Manager} $\ast$ \hyperlink{classQueryProcessor_a3cc164cc6022e092ca7cc42d2be88aa7}{storage\+\_\+manager\+\_\+}
\item 
int \hyperlink{classQueryProcessor_ac62ff5cd45c6813c674f00d5f7c379fb}{err\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class implements the query processor module, which is responsible for processing the various queries. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{classQueryProcessor_a07816ecd785ad36631c525e3babaa6b0}{}\index{Query\+Processor@{Query\+Processor}!Query\+Processor@{Query\+Processor}}
\index{Query\+Processor@{Query\+Processor}!Query\+Processor@{Query\+Processor}}
\subsubsection[{Query\+Processor}]{\setlength{\rightskip}{0pt plus 5cm}Query\+Processor\+::\+Query\+Processor (
\begin{DoxyParamCaption}
\item[{{\bf Storage\+Manager} $\ast$}]{storage\+\_\+manager}
\end{DoxyParamCaption}
)}\label{classQueryProcessor_a07816ecd785ad36631c525e3babaa6b0}
Simple constructor. The storage manager is the module the query processor interefaces with. 

\subsection{Member Function Documentation}
\hypertarget{classQueryProcessor_ad30605917457abc19c3e5606fbb6d581}{}\index{Query\+Processor@{Query\+Processor}!export\+\_\+csv@{export\+\_\+csv}}
\index{export\+\_\+csv@{export\+\_\+csv}!Query\+Processor@{Query\+Processor}}
\subsubsection[{export\+\_\+csv}]{\setlength{\rightskip}{0pt plus 5cm}int Query\+Processor\+::export\+\_\+csv (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{const std\+::string \&}]{filename, }
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{dim\+\_\+names, }
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{attribute\+\_\+names, }
\item[{bool}]{reverse}
\end{DoxyParamCaption}
) const}\label{classQueryProcessor_ad30605917457abc19c3e5606fbb6d581}
Exports an array to a C\+S\+V file. Each line in the C\+S\+V file represents a logical cell comprised of coordinates and attribute values. The coordinates are written first, and then the attribute values, following the order as defined in the schema of the array. The input dimension and attribute names allow for selective exporting of coordinates and attribute values respectively. Argument reverse allows for optionally exporting the cells in reverse order (if it is true). \hypertarget{classQueryProcessor_ac47f5cc3f8ab2e025002a1dbcf07e736}{}\index{Query\+Processor@{Query\+Processor}!export\+\_\+csv@{export\+\_\+csv}}
\index{export\+\_\+csv@{export\+\_\+csv}!Query\+Processor@{Query\+Processor}}
\subsubsection[{export\+\_\+csv}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void Query\+Processor\+::export\+\_\+csv (
\begin{DoxyParamCaption}
\item[{int}]{ad, }
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema, }
\item[{const std\+::string \&}]{filename, }
\item[{const std\+::vector$<$ int $>$ \&}]{dim\+\_\+ids, }
\item[{const std\+::vector$<$ int $>$ \&}]{attribute\+\_\+ids}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_ac47f5cc3f8ab2e025002a1dbcf07e736}
Exports an array to a C\+S\+V file. Each line in the C\+S\+V file represents a logical cell comprised of coordinates and attribute values. The coordinates are written first, and then the attribute values, following the order as defined in the schema of the array. The function is templated on the coordinates type. It takes as input an array descriptor instead of its name. The input dimension and attribute ids allow for selective exporting of coordinates and attribute values respectively. Note that the attribute ids must N\+O\+T contain the id of the coordinates. \hypertarget{classQueryProcessor_ac490bbe57b408f2b09b96232ff49b88c}{}\index{Query\+Processor@{Query\+Processor}!export\+\_\+csv\+\_\+reverse@{export\+\_\+csv\+\_\+reverse}}
\index{export\+\_\+csv\+\_\+reverse@{export\+\_\+csv\+\_\+reverse}!Query\+Processor@{Query\+Processor}}
\subsubsection[{export\+\_\+csv\+\_\+reverse}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void Query\+Processor\+::export\+\_\+csv\+\_\+reverse (
\begin{DoxyParamCaption}
\item[{int}]{ad, }
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema, }
\item[{const std\+::string \&}]{filename, }
\item[{const std\+::vector$<$ int $>$ \&}]{dim\+\_\+ids, }
\item[{const std\+::vector$<$ int $>$ \&}]{attribute\+\_\+ids}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_ac490bbe57b408f2b09b96232ff49b88c}
Same as Query\+Processor\+::export\+\_\+to\+\_\+csv, but the cells are exporting to the C\+S\+V file in reverse order. \hypertarget{classQueryProcessor_a0ca14aca91dfa55c6acb82ed9f2c7e08}{}\index{Query\+Processor@{Query\+Processor}!parse\+\_\+attribute\+\_\+names@{parse\+\_\+attribute\+\_\+names}}
\index{parse\+\_\+attribute\+\_\+names@{parse\+\_\+attribute\+\_\+names}!Query\+Processor@{Query\+Processor}}
\subsubsection[{parse\+\_\+attribute\+\_\+names}]{\setlength{\rightskip}{0pt plus 5cm}int Query\+Processor\+::parse\+\_\+attribute\+\_\+names (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{attribute\+\_\+names, }
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema, }
\item[{std\+::vector$<$ int $>$ \&}]{attribute\+\_\+ids, }
\item[{std\+::string \&}]{err\+\_\+msg}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_a0ca14aca91dfa55c6acb82ed9f2c7e08}
Parses the attribute names and returns the corresponding attribute ids, which will be used to initialize a cell iterator. \hypertarget{classQueryProcessor_a9dc7581a12ae6ab63518a372ec1702d8}{}\index{Query\+Processor@{Query\+Processor}!parse\+\_\+dim\+\_\+names@{parse\+\_\+dim\+\_\+names}}
\index{parse\+\_\+dim\+\_\+names@{parse\+\_\+dim\+\_\+names}!Query\+Processor@{Query\+Processor}}
\subsubsection[{parse\+\_\+dim\+\_\+names}]{\setlength{\rightskip}{0pt plus 5cm}int Query\+Processor\+::parse\+\_\+dim\+\_\+names (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{dim\+\_\+names, }
\item[{const {\bf Array\+Schema} $\ast$}]{array\+\_\+schema, }
\item[{std\+::vector$<$ int $>$ \&}]{dim\+\_\+ids, }
\item[{std\+::string \&}]{err\+\_\+msg}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_a9dc7581a12ae6ab63518a372ec1702d8}
Parses the dimension names and returns the corresponding dimension ids. \hypertarget{classQueryProcessor_add4b7d3e4e75b226016f385d09001f1e}{}\index{Query\+Processor@{Query\+Processor}!subarray@{subarray}}
\index{subarray@{subarray}!Query\+Processor@{Query\+Processor}}
\subsubsection[{subarray}]{\setlength{\rightskip}{0pt plus 5cm}int Query\+Processor\+::subarray (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{array\+\_\+name, }
\item[{const std\+::vector$<$ double $>$ \&}]{range, }
\item[{const std\+::string \&}]{result\+\_\+array\+\_\+name, }
\item[{const std\+::vector$<$ std\+::string $>$ \&}]{attribute\+\_\+names}
\end{DoxyParamCaption}
) const}\label{classQueryProcessor_add4b7d3e4e75b226016f385d09001f1e}
A subarray query creates a new array from the input array, containing only the cells whose coordinates fall into the input range. The new array will have the input result name. The fourth argument specifies which attributes from the input array will be written to the output array. If this list is empty, then all attributes of the input array are written to the output array. The last argument allows for optionally writing the cells to the output in reverse order (if it is true). \hypertarget{classQueryProcessor_a382d9d3f7639ba3594877872e0bbcd95}{}\index{Query\+Processor@{Query\+Processor}!subarray@{subarray}}
\index{subarray@{subarray}!Query\+Processor@{Query\+Processor}}
\subsubsection[{subarray}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void Query\+Processor\+::subarray (
\begin{DoxyParamCaption}
\item[{int}]{ad, }
\item[{const T $\ast$}]{range, }
\item[{int}]{result\+\_\+ad, }
\item[{const std\+::vector$<$ int $>$ \&}]{attribute\+\_\+ids}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_a382d9d3f7639ba3594877872e0bbcd95}
A subarray query creates a new array from the input array, containing only the cells whose coordinates fall into the input range. The new array will have the input result name. The function is templated on the coordinates type. It takes as input array descriptors instead of names. The input attribute ids allow for selective writing of attribute values to the output array, respectively. Note that the attribute ids must N\+O\+T contain the id of the coordinates. Also the attribute ids can be in an arbitrary order (not necessarily the one specified in the input array). 

\subsection{Member Data Documentation}
\hypertarget{classQueryProcessor_ac62ff5cd45c6813c674f00d5f7c379fb}{}\index{Query\+Processor@{Query\+Processor}!err\+\_\+@{err\+\_\+}}
\index{err\+\_\+@{err\+\_\+}!Query\+Processor@{Query\+Processor}}
\subsubsection[{err\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}int Query\+Processor\+::err\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_ac62ff5cd45c6813c674f00d5f7c379fb}
The current error code. It is 0 on success. \hypertarget{classQueryProcessor_a3cc164cc6022e092ca7cc42d2be88aa7}{}\index{Query\+Processor@{Query\+Processor}!storage\+\_\+manager\+\_\+@{storage\+\_\+manager\+\_\+}}
\index{storage\+\_\+manager\+\_\+@{storage\+\_\+manager\+\_\+}!Query\+Processor@{Query\+Processor}}
\subsubsection[{storage\+\_\+manager\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Storage\+Manager}$\ast$ Query\+Processor\+::storage\+\_\+manager\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classQueryProcessor_a3cc164cc6022e092ca7cc42d2be88aa7}
The \hyperlink{classStorageManager}{Storage\+Manager} object the \hyperlink{classQueryProcessor}{Query\+Processor} will be interfacing with. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
core/include/query\+\_\+processor/\hyperlink{query__processor_8h}{query\+\_\+processor.\+h}\end{DoxyCompactItemize}
