<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TileDB: StorageManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TileDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classStorageManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StorageManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="storage__manager_8h_source.html">storage_manager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a029dfd29d09cbf61ea0c7151526d3924"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a029dfd29d09cbf61ea0c7151526d3924">OpenArrays</a></td></tr>
<tr class="separator:a029dfd29d09cbf61ea0c7151526d3924"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7071b12eb47fd6a535a8d26ad466298e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a7071b12eb47fd6a535a8d26ad466298e">StorageManager</a> (const std::string &amp;path, const <a class="el" href="classMPIHandler.html">MPIHandler</a> *mpi_handler=NULL, size_t segment_size=<a class="el" href="special__values_8h.html#acbe07a3c3fe2056125230c357f85b870">SEGMENT_SIZE</a>)</td></tr>
<tr class="separator:a7071b12eb47fd6a535a8d26ad466298e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b35000dab64f83ee77d6847f0104c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a10b35000dab64f83ee77d6847f0104c1">~StorageManager</a> ()</td></tr>
<tr class="separator:a10b35000dab64f83ee77d6847f0104c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d5a1f6f429513b5ecff122f3e66559"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a14d5a1f6f429513b5ecff122f3e66559">err</a> () const </td></tr>
<tr class="separator:a14d5a1f6f429513b5ecff122f3e66559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2b393b3767817d991fb88ff6c91ed7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#aac2b393b3767817d991fb88ff6c91ed7">set_segment_size</a> (size_t segment_size)</td></tr>
<tr class="separator:aac2b393b3767817d991fb88ff6c91ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7132db9fd7d84701714150e2a8c8aa16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a7132db9fd7d84701714150e2a8c8aa16">array_defined</a> (const std::string &amp;array_name) const </td></tr>
<tr class="separator:a7132db9fd7d84701714150e2a8c8aa16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94256a896d0b9f38daccdf88d073bd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#ac94256a896d0b9f38daccdf88d073bd6">clear_array</a> (const std::string &amp;array_name)</td></tr>
<tr class="separator:ac94256a896d0b9f38daccdf88d073bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3713c351280d006c90c4153a2e8cad3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a3713c351280d006c90c4153a2e8cad3b">close_array</a> (int ad)</td></tr>
<tr class="separator:a3713c351280d006c90c4153a2e8cad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35a50120983ab4778b76190134e137a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#af35a50120983ab4778b76190134e137a">define_array</a> (const <a class="el" href="classArraySchema.html">ArraySchema</a> *array_schema)</td></tr>
<tr class="separator:af35a50120983ab4778b76190134e137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a295f0da9291039eb988fe98acb399"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#ae9a295f0da9291039eb988fe98acb399">delete_array</a> (const std::string &amp;array_name)</td></tr>
<tr class="separator:ae9a295f0da9291039eb988fe98acb399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b93df7ce3a2360740862aef2bee92a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a50b93df7ce3a2360740862aef2bee92a">forced_close_array</a> (int ad)</td></tr>
<tr class="separator:a50b93df7ce3a2360740862aef2bee92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813989d59bf03222008993b3ea895bec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a813989d59bf03222008993b3ea895bec">get_array_schema</a> (int ad, const <a class="el" href="classArraySchema.html">ArraySchema</a> *&amp;array_schema, std::string &amp;err_msg) const </td></tr>
<tr class="separator:a813989d59bf03222008993b3ea895bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bfad3c8345c01bd26903a427488140"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a97bfad3c8345c01bd26903a427488140">get_array_schema</a> (const std::string &amp;array_name, <a class="el" href="classArraySchema.html">ArraySchema</a> *&amp;array_schema) const </td></tr>
<tr class="separator:a97bfad3c8345c01bd26903a427488140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa684003b8c78c5b6a13522cf47d6c7cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#aa684003b8c78c5b6a13522cf47d6c7cb">load_sorted_bin</a> (const std::string &amp;dirname, const std::string &amp;array_name, std::string &amp;err_msg)</td></tr>
<tr class="separator:aa684003b8c78c5b6a13522cf47d6c7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566e1872beefb0b08364d03a0e82f4a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a566e1872beefb0b08364d03a0e82f4a7">open_array</a> (const std::string &amp;array_name, const char *mode, std::string &amp;err_msg)</td></tr>
<tr class="separator:a566e1872beefb0b08364d03a0e82f4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4937c8bb623728447a003968edb55ce5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4937c8bb623728447a003968edb55ce5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a4937c8bb623728447a003968edb55ce5">begin</a> (int ad) const </td></tr>
<tr class="separator:a4937c8bb623728447a003968edb55ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af14b46b015d01b6a113edb781ccd38"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5af14b46b015d01b6a113edb781ccd38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a5af14b46b015d01b6a113edb781ccd38">begin</a> (int ad, const std::vector&lt; int &gt; &amp;attribute_ids) const </td></tr>
<tr class="separator:a5af14b46b015d01b6a113edb781ccd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11958acbf3550a0b6e9ca8b028b76889"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a11958acbf3550a0b6e9ca8b028b76889"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a11958acbf3550a0b6e9ca8b028b76889">begin</a> (int ad, const T *range) const </td></tr>
<tr class="separator:a11958acbf3550a0b6e9ca8b028b76889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32e07289e6803e99e835330afbec0de"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa32e07289e6803e99e835330afbec0de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#aa32e07289e6803e99e835330afbec0de">begin</a> (int ad, const T *range, const std::vector&lt; int &gt; &amp;attribute_ids) const </td></tr>
<tr class="separator:aa32e07289e6803e99e835330afbec0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ce673fdf84d4672ff065743614078d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4ce673fdf84d4672ff065743614078d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#af4ce673fdf84d4672ff065743614078d">rbegin</a> (int ad) const </td></tr>
<tr class="separator:af4ce673fdf84d4672ff065743614078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9037e3c1521b947eeabee8961e392419"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9037e3c1521b947eeabee8961e392419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a9037e3c1521b947eeabee8961e392419">rbegin</a> (int ad, const std::vector&lt; int &gt; &amp;attribute_ids) const </td></tr>
<tr class="separator:a9037e3c1521b947eeabee8961e392419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34c8537c5835b7e43333da973886a32"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac34c8537c5835b7e43333da973886a32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#ac34c8537c5835b7e43333da973886a32">rbegin</a> (int ad, const T *range) const </td></tr>
<tr class="separator:ac34c8537c5835b7e43333da973886a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2396f9d78a636d95255abd26f9616fa9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2396f9d78a636d95255abd26f9616fa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a2396f9d78a636d95255abd26f9616fa9">rbegin</a> (int ad, const T *range, const std::vector&lt; int &gt; &amp;attribute_ids) const </td></tr>
<tr class="separator:a2396f9d78a636d95255abd26f9616fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3da6e2e682cf3f796ab359801758b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#acc3da6e2e682cf3f796ab359801758b2">read_cells</a> (int ad, const void *range, const std::vector&lt; int &gt; &amp;attribute_ids, void *&amp;cells, size_t &amp;cells_size) const </td></tr>
<tr class="separator:acc3da6e2e682cf3f796ab359801758b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28e02f51d6ae440348474662699cdaa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa28e02f51d6ae440348474662699cdaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#aa28e02f51d6ae440348474662699cdaa">read_cells</a> (int ad, const T *range, const std::vector&lt; int &gt; &amp;attribute_ids, void *&amp;cells, size_t &amp;cells_size) const </td></tr>
<tr class="separator:aa28e02f51d6ae440348474662699cdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e39288e7a40b6d6c9ab095fdbac48d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a39e39288e7a40b6d6c9ab095fdbac48d">read_cells</a> (int ad, const void *range, const std::vector&lt; int &gt; &amp;attribute_ids, void *&amp;cells, size_t &amp;cells_size, int rcv_rank) const </td></tr>
<tr class="separator:a39e39288e7a40b6d6c9ab095fdbac48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1ca5278f9e094319537dce4db6a494"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7d1ca5278f9e094319537dce4db6a494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a7d1ca5278f9e094319537dce4db6a494">read_cells</a> (int ad, const T *range, const std::vector&lt; int &gt; &amp;attribute_ids, void *&amp;cells, size_t &amp;cell_num, int rcv_rank) const </td></tr>
<tr class="separator:a7d1ca5278f9e094319537dce4db6a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c40375b8672c978611a7056714b67df"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c40375b8672c978611a7056714b67df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a9c40375b8672c978611a7056714b67df">write_cell</a> (int ad, const void *cell) const </td></tr>
<tr class="separator:a9c40375b8672c978611a7056714b67df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a8332dfdf89b8268c4b9327fc81392"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92a8332dfdf89b8268c4b9327fc81392"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a92a8332dfdf89b8268c4b9327fc81392">write_cell_sorted</a> (int ad, const void *cell) const </td></tr>
<tr class="separator:a92a8332dfdf89b8268c4b9327fc81392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0758bf4fea21e0909d409d04c4f8123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#af0758bf4fea21e0909d409d04c4f8123">write_cells</a> (int ad, const void *cells, size_t cells_size) const </td></tr>
<tr class="separator:af0758bf4fea21e0909d409d04c4f8123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb958e2bbe6cc306e308d8c10aa1fba9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adb958e2bbe6cc306e308d8c10aa1fba9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#adb958e2bbe6cc306e308d8c10aa1fba9">write_cells</a> (int ad, const void *cells, size_t cells_size) const </td></tr>
<tr class="separator:adb958e2bbe6cc306e308d8c10aa1fba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c96ed26b380e0907af6fe59a92be672"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a0c96ed26b380e0907af6fe59a92be672">write_cells_sorted</a> (int ad, const void *cells, size_t cells_size) const </td></tr>
<tr class="separator:a0c96ed26b380e0907af6fe59a92be672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe89e9ee8f8ac605003dd873fcc2725"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adfe89e9ee8f8ac605003dd873fcc2725"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager.html#adfe89e9ee8f8ac605003dd873fcc2725">write_cells_sorted</a> (int ad, const void *cells, size_t cells_size) const </td></tr>
<tr class="separator:adfe89e9ee8f8ac605003dd873fcc2725"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2cba3c99c6695df7d21836e75b806143"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a2cba3c99c6695df7d21836e75b806143">get_version</a> ()</td></tr>
<tr class="separator:a2cba3c99c6695df7d21836e75b806143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3c61cd62233f323613e966932ddcc288"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a3c61cd62233f323613e966932ddcc288">check_on_open_array</a> (const std::string &amp;array_name, const char *mode, std::string &amp;err_msg) const </td></tr>
<tr class="separator:a3c61cd62233f323613e966932ddcc288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99148b22ffc6d3c3220777188070d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a4e99148b22ffc6d3c3220777188070d5">invalid_array_mode</a> (const char *mode) const </td></tr>
<tr class="separator:a4e99148b22ffc6d3c3220777188070d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14ee151d33680cbb03e1bec5a3f26dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#ab14ee151d33680cbb03e1bec5a3f26dd">set_workspace</a> (const std::string &amp;path)</td></tr>
<tr class="separator:ab14ee151d33680cbb03e1bec5a3f26dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8823ffd11bf4a62ae08ab20bc2019b87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a8823ffd11bf4a62ae08ab20bc2019b87">store_array</a> (<a class="el" href="classArray.html">Array</a> *array)</td></tr>
<tr class="separator:a8823ffd11bf4a62ae08ab20bc2019b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3d34312ce7468b1c708c8a3bc5e2ea08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classArray.html">Array</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a3d34312ce7468b1c708c8a3bc5e2ea08">arrays_</a></td></tr>
<tr class="separator:a3d34312ce7468b1c708c8a3bc5e2ea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a36b5f640ef688962487bc1869b61e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a3a36b5f640ef688962487bc1869b61e1">err_</a></td></tr>
<tr class="separator:a3a36b5f640ef688962487bc1869b61e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4d0447d153e3a33391d0663a63fdad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStorageManager.html#a029dfd29d09cbf61ea0c7151526d3924">OpenArrays</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a4f4d0447d153e3a33391d0663a63fdad">open_arrays_</a></td></tr>
<tr class="separator:a4f4d0447d153e3a33391d0663a63fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2070c85d3402bd1628d3d5fe7391c3e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPIHandler.html">MPIHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#af2070c85d3402bd1628d3d5fe7391c3e">mpi_handler_</a></td></tr>
<tr class="separator:af2070c85d3402bd1628d3d5fe7391c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa2414c2d99753a416eaa3e2794fdd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#ac1fa2414c2d99753a416eaa3e2794fdd">segment_size_</a></td></tr>
<tr class="separator:ac1fa2414c2d99753a416eaa3e2794fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab615f83f9697bbd2dd4f9fbb79f81f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a3ab615f83f9697bbd2dd4f9fbb79f81f">workspace_</a></td></tr>
<tr class="separator:a3ab615f83f9697bbd2dd4f9fbb79f81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f86db65bc93b86d3bbcf46de12d4f3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager.html#a70f86db65bc93b86d3bbcf46de12d4f3">write_state_max_size_</a></td></tr>
<tr class="separator:a70f86db65bc93b86d3bbcf46de12d4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A storage manager object is responsible for storing/fetching tiles to/from the disk. It maintains book-keeping structures in main memory to efficiently locate the tile data on disk. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a029dfd29d09cbf61ea0c7151526d3924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, int&gt; <a class="el" href="classStorageManager.html#a029dfd29d09cbf61ea0c7151526d3924">StorageManager::OpenArrays</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mnemonic: [array_name + "_" + array_name] &ndash;&gt; array_descriptor </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7071b12eb47fd6a535a8d26ad466298e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageManager::StorageManager </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPIHandler.html">MPIHandler</a> *&#160;</td>
          <td class="paramname"><em>mpi_handler</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment_size</em> = <code><a class="el" href="special__values_8h.html#acbe07a3c3fe2056125230c357f85b870">SEGMENT_SIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Upon its creation, a storage manager object needs a workspace path. The latter is a folder in the disk where the storage manager creates all the tile and book-keeping data. Note that the input path must exist. If the workspace folder exists, the function does nothing, otherwise it creates it. The segment size determines the amount of data exchanged in an I/O operation between the disk and the main memory. The MPI handler takes care of the MPI communication in the distributed setting where there are multiple TileDB processes runnign simultaneously. </p>

</div>
</div>
<a class="anchor" id="a10b35000dab64f83ee77d6847f0104c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageManager::~StorageManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When a storage manager object is deleted, it closes all open arrays. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7132db9fd7d84701714150e2a8c8aa16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::array_defined </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the array has been defined. </p>

</div>
</div>
<a class="anchor" id="a4937c8bb623728447a003968edb55ce5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt;T&gt; StorageManager::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and returns a cell iterator. </p>

</div>
</div>
<a class="anchor" id="a5af14b46b015d01b6a113edb781ccd38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt;T&gt; StorageManager::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and a list of attribute ids. It returns a cell iterator that iterates over the specified attributes. </p>

</div>
</div>
<a class="anchor" id="a11958acbf3550a0b6e9ca8b028b76889"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt;T&gt; StorageManager::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and a range. It returns a cell iterator that iterates only over the cells whose coordinates lie within the input range (following the global cell order). </p>

</div>
</div>
<a class="anchor" id="aa32e07289e6803e99e835330afbec0de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstCellIterator.html">ArrayConstCellIterator</a>&lt;T&gt; StorageManager::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor, a range, and a list of attribute ids. It returns a cell iterator that iterates only over the cells whose coordinates lie within the input range (following the global cell order), and only on the specified attributes. </p>

</div>
</div>
<a class="anchor" id="a3c61cd62233f323613e966932ddcc288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::check_on_open_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>err_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks when opening an array. </p>

</div>
</div>
<a class="anchor" id="ac94256a896d0b9f38daccdf88d073bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::clear_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all the fragments of an array. The array remains defined. </p>

</div>
</div>
<a class="anchor" id="a3713c351280d006c90c4153a2e8cad3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::close_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes an array. </p>

</div>
</div>
<a class="anchor" id="af35a50120983ab4778b76190134e137a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::define_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines an array (stores its array schema). </p>

</div>
</div>
<a class="anchor" id="ae9a295f0da9291039eb988fe98acb399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::delete_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>It deletes an array (regardless of whether it is open or not). </p>

</div>
</div>
<a class="anchor" id="a14d5a1f6f429513b5ecff122f3e66559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::err </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current error code. It is 0 upon success. </p>

</div>
</div>
<a class="anchor" id="a50b93df7ce3a2360740862aef2bee92a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::forced_close_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces an array to close. This is done during abnormal execution. If the array was opened in write or append mode, the last fragment must be deleted (since it was not properly loaded). </p>

</div>
</div>
<a class="anchor" id="a813989d59bf03222008993b3ea895bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::get_array_schema </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&amp;&#160;</td>
          <td class="paramname"><em>array_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>err_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the schema of an array. The input is an array descriptor. </p>

</div>
</div>
<a class="anchor" id="a97bfad3c8345c01bd26903a427488140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::get_array_schema </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArraySchema.html">ArraySchema</a> *&amp;&#160;</td>
          <td class="paramname"><em>array_schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the schema of an array. </p>

</div>
</div>
<a class="anchor" id="a2cba3c99c6695df7d21836e75b806143"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void StorageManager::get_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints the version of the storage manager to the standard output. </p>

</div>
</div>
<a class="anchor" id="a4e99148b22ffc6d3c3220777188070d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::invalid_array_mode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the validity of the array mode. </p>

</div>
</div>
<a class="anchor" id="aa684003b8c78c5b6a13522cf47d6c7cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::load_sorted_bin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>err_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads data into an array, which are stored in binary files in the input directory. Each file stores the cells in binary form, sorted on the global cell order specified in the array schema. </p>

</div>
</div>
<a class="anchor" id="a566e1872beefb0b08364d03a0e82f4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::open_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>err_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens an array in the input mode. It returns an 'array descriptor', which is used in subsequent array operations. Currently, the following modes are supported:</p>
<p>"r": Read mode</p>
<p>"w": Write mode (if the array exists, it is deleted)</p>
<p>"a": Append mode </p>

</div>
</div>
<a class="anchor" id="af4ce673fdf84d4672ff065743614078d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt;T&gt; StorageManager::rbegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and returns a cell iterator. </p>

</div>
</div>
<a class="anchor" id="a9037e3c1521b947eeabee8961e392419"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt;T&gt; StorageManager::rbegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and a list of attribute ids. It returns a cell iterator that iterates over the specified attributes. </p>

</div>
</div>
<a class="anchor" id="ac34c8537c5835b7e43333da973886a32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt;T&gt; StorageManager::rbegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and a range. It returns a cell iterator that iterates only over the cells whose coordinates lie within the input range (following the global cell order). </p>

</div>
</div>
<a class="anchor" id="a2396f9d78a636d95255abd26f9616fa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArrayConstReverseCellIterator.html">ArrayConstReverseCellIterator</a>&lt;T&gt; StorageManager::rbegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor, a range, and a list of attribute ids. It returns a cell iterator that iterates only over the cells whose coordinates lie within the input range (following the global cell order), and only on the specified attributes. </p>

</div>
</div>
<a class="anchor" id="acc3da6e2e682cf3f796ab359801758b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::read_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cells_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and a multi-dimensional range, and returns the cells whose coordinates fall inside the range, as well as their collective size in bytes (last two arguments). </p>

</div>
</div>
<a class="anchor" id="aa28e02f51d6ae440348474662699cdaa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::read_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cells_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor and a multi-dimensional range, and returns the cells whose coordinates fall inside the range, as well as their collective size in bytes (last two arguments). </p>

</div>
</div>
<a class="anchor" id="a39e39288e7a40b6d6c9ab095fdbac48d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::read_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cells_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rcv_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor, a multi-dimensional range and the rank of the process that will receive the data. It returns form all the processes the cells whose coordinates fall inside the input range, as well as their collective size in bytes (last two arguments). </p>

</div>
</div>
<a class="anchor" id="a7d1ca5278f9e094319537dce4db6a494"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::read_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cell_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rcv_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes as input an array descriptor, a multi-dimensional range and the rank of the process that will receive the data. It returns form all the processes the cells whose coordinates fall inside the input range, as well as their collective size in bytes (last two arguments). </p>

</div>
</div>
<a class="anchor" id="aac2b393b3767817d991fb88ff6c91ed7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::set_segment_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the default segment size. </p>

</div>
</div>
<a class="anchor" id="ab14ee151d33680cbb03e1bec5a3f26dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::set_workspace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simply sets the workspace. </p>

</div>
</div>
<a class="anchor" id="a8823ffd11bf4a62ae08ab20bc2019b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::store_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classArray.html">Array</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores an array object and returns an array descriptor. </p>

</div>
</div>
<a class="anchor" id="a9c40375b8672c978611a7056714b67df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::write_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell to an array. It takes as input an array descriptor, and a cell pointer. The cell has the following format: The coordinates appear first, and then the attribute values in the same order as the attributes are defined in the array schema. </p>

</div>
</div>
<a class="anchor" id="a92a8332dfdf89b8268c4b9327fc81392"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::write_cell_sorted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell to an array. It takes as input an array descriptor, and a cell pointer. The cell has the following format: The coordinates appear first, and then the attribute values in the same order as the attributes are defined in the array schema. This function is used only when it is guaranteed that the cells are written respecting the global cell order as specified in the array schema. </p>

</div>
</div>
<a class="anchor" id="af0758bf4fea21e0909d409d04c4f8123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::write_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cells_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a set of cells to an array. It takes as input an array descriptor, and a pointer to cells, which are serialized one after the other. Each cell has the following format: The coordinates appear first, and then the attribute values in the same order as the attributes are defined in the array schema. </p>

</div>
</div>
<a class="anchor" id="adb958e2bbe6cc306e308d8c10aa1fba9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::write_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cells_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a set of cells to an array. It takes as input an array descriptor, and a pointer to cells, which are serialized one after the other. Each cell has the following format: The coordinates appear first, and then the attribute values in the same order as the attributes are defined in the array schema. </p>

</div>
</div>
<a class="anchor" id="a0c96ed26b380e0907af6fe59a92be672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::write_cells_sorted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cells_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a set of cells to an array. It takes as input an array descriptor, and a pointer to cells, which are serialized one after the other. Each cell has the following format: The coordinates appear first, and then the attribute values in the same order as the attributes are defined in the array schema. This function is used only when it is guaranteed that the cells are written respecting the global cell order as specified in the array schema. </p>

</div>
</div>
<a class="anchor" id="adfe89e9ee8f8ac605003dd873fcc2725"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::write_cells_sorted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cells_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a set of cells to an array. It takes as input an array descriptor, and a pointer to cells, which are serialized one after the other. Each cell has the following format: The coordinates appear first, and then the attribute values in the same order as the attributes are defined in the array schema. This function is used only when it is guaranteed that the cells are written respecting the global cell order as specified in the array schema. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3d34312ce7468b1c708c8a3bc5e2ea08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classArray.html">Array</a>** StorageManager::arrays_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores all the open arrays. </p>

</div>
</div>
<a class="anchor" id="a3a36b5f640ef688962487bc1869b61e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StorageManager::err_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Error code (0 on success). </p>

</div>
</div>
<a class="anchor" id="af2070c85d3402bd1628d3d5fe7391c3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPIHandler.html">MPIHandler</a>* StorageManager::mpi_handler_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The MPI communication handler. </p>

</div>
</div>
<a class="anchor" id="a4f4d0447d153e3a33391d0663a63fdad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager.html#a029dfd29d09cbf61ea0c7151526d3924">OpenArrays</a> StorageManager::open_arrays_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Keeps track of the descriptors of the currently open arrays. </p>

</div>
</div>
<a class="anchor" id="ac1fa2414c2d99753a416eaa3e2794fdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t StorageManager::segment_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the amount of data that can be exchanged between the hard disk and the main memory in a single I/O operation. </p>

</div>
</div>
<a class="anchor" id="a3ab615f83f9697bbd2dd4f9fbb79f81f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string StorageManager::workspace_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is a folder in the disk where the storage manager creates all the array data (i.e., tile and index files). </p>

</div>
</div>
<a class="anchor" id="a70f86db65bc93b86d3bbcf46de12d4f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t StorageManager::write_state_max_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Max memory size of the write state when creating an array fragment. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/include/storage_manager/<a class="el" href="storage__manager_8h_source.html">storage_manager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 29 2015 17:52:58 for TileDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
