<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TileDB: StorageManager::Array::const_reverse_cell_iterator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TileDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classStorageManager.html">StorageManager</a></li><li class="navelem"><a class="el" href="classStorageManager_1_1Array.html">Array</a></li><li class="navelem"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StorageManager::Array::const_reverse_cell_iterator&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="storage__manager_8h_source.html">storage_manager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39c494e646fcc4700dc301229665eb22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a39c494e646fcc4700dc301229665eb22">const_reverse_cell_iterator</a> ()</td></tr>
<tr class="separator:a39c494e646fcc4700dc301229665eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7778814f01a6600067edba1e6b3d710e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a7778814f01a6600067edba1e6b3d710e">const_reverse_cell_iterator</a> (<a class="el" href="classStorageManager_1_1Array.html">Array</a> *array)</td></tr>
<tr class="separator:a7778814f01a6600067edba1e6b3d710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3243c47a5b32b9e242cf024480dc7eb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a3243c47a5b32b9e242cf024480dc7eb4">const_reverse_cell_iterator</a> (<a class="el" href="classStorageManager_1_1Array.html">Array</a> *array, const std::vector&lt; int &gt; &amp;fragment_ids, bool return_del)</td></tr>
<tr class="separator:a3243c47a5b32b9e242cf024480dc7eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2de2158ea0892c3d47e6854f92a97f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#add2de2158ea0892c3d47e6854f92a97f">const_reverse_cell_iterator</a> (<a class="el" href="classStorageManager_1_1Array.html">Array</a> *array, const std::vector&lt; int &gt; &amp;<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ad4e0c39197231c45db9faead252c2dd0">attribute_ids</a>)</td></tr>
<tr class="separator:add2de2158ea0892c3d47e6854f92a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf9e32d2a0ba1eeb3f5543ed6db62e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#afcf9e32d2a0ba1eeb3f5543ed6db62e4">const_reverse_cell_iterator</a> (<a class="el" href="classStorageManager_1_1Array.html">Array</a> *array, const T *range)</td></tr>
<tr class="separator:afcf9e32d2a0ba1eeb3f5543ed6db62e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae041950dda2fe99f8a3d9aa0211da613"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ae041950dda2fe99f8a3d9aa0211da613">const_reverse_cell_iterator</a> (<a class="el" href="classStorageManager_1_1Array.html">Array</a> *array, const T *range, const std::vector&lt; int &gt; &amp;<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ad4e0c39197231c45db9faead252c2dd0">attribute_ids</a>)</td></tr>
<tr class="separator:ae041950dda2fe99f8a3d9aa0211da613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e64ec535427e572be20d364f25d04dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a1e64ec535427e572be20d364f25d04dc">~const_reverse_cell_iterator</a> ()</td></tr>
<tr class="separator:a1e64ec535427e572be20d364f25d04dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e0c39197231c45db9faead252c2dd0"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ad4e0c39197231c45db9faead252c2dd0">attribute_ids</a> () const </td></tr>
<tr class="separator:ad4e0c39197231c45db9faead252c2dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1017ce348c44bb7623a8ad36b28bf92"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ad1017ce348c44bb7623a8ad36b28bf92">cell_size</a> () const </td></tr>
<tr class="separator:ad1017ce348c44bb7623a8ad36b28bf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8438b91cf2d63197c84544a6afe8f9b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#aa8438b91cf2d63197c84544a6afe8f9b">cell_size</a> (int fragment_id) const </td></tr>
<tr class="separator:aa8438b91cf2d63197c84544a6afe8f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97475a3e5aa93f64f9962d5dc39ff9f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a97475a3e5aa93f64f9962d5dc39ff9f1">end</a> () const </td></tr>
<tr class="separator:a97475a3e5aa93f64f9962d5dc39ff9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb79b3277f6e49a03c0673c774c3c123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#abb79b3277f6e49a03c0673c774c3c123">operator++</a> ()</td></tr>
<tr class="separator:abb79b3277f6e49a03c0673c774c3c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477673a8462e6aa41d4ed8c8078dcd46"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a477673a8462e6aa41d4ed8c8078dcd46">operator*</a> ()</td></tr>
<tr class="separator:a477673a8462e6aa41d4ed8c8078dcd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aedaabb27f3c800ec4aee8fb1ee917b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#aedaabb27f3c800ec4aee8fb1ee917b51">advance_cell</a> (int fragment_id)</td></tr>
<tr class="separator:aedaabb27f3c800ec4aee8fb1ee917b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36d101497be184e263d5a23774c974b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#aa36d101497be184e263d5a23774c974b">advance_cell_in_range</a> (int fragment_id)</td></tr>
<tr class="separator:aa36d101497be184e263d5a23774c974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f63d1b1b268e5c3727d5df4395a94d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ac6f63d1b1b268e5c3727d5df4395a94d">find_next_cell_in_range</a> (int fragment_id)</td></tr>
<tr class="separator:ac6f63d1b1b268e5c3727d5df4395a94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2ee1cea305bd1c4e3e939d191efa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a49f2ee1cea305bd1c4e3e939d191efa1">get_next_cell</a> ()</td></tr>
<tr class="separator:a49f2ee1cea305bd1c4e3e939d191efa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0757d5ce0f03b978172a40b6d910dd25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a0757d5ce0f03b978172a40b6d910dd25">init_iterators</a> ()</td></tr>
<tr class="separator:a0757d5ce0f03b978172a40b6d910dd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa029ee5fd04ddd1ba94f866a54c7870c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#aa029ee5fd04ddd1ba94f866a54c7870c">init_iterators_in_range</a> ()</td></tr>
<tr class="separator:aa029ee5fd04ddd1ba94f866a54c7870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a783504da48f6577a2ad5d1db556aed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a3a783504da48f6577a2ad5d1db556aed">precedes</a> (const <a class="el" href="classTile_1_1const__reverse__cell__iterator.html">Tile::const_reverse_cell_iterator</a> &amp;it_A, const <a class="el" href="classTile_1_1const__reverse__cell__iterator.html">Tile::const_reverse_cell_iterator</a> &amp;it_B) const </td></tr>
<tr class="separator:a3a783504da48f6577a2ad5d1db556aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae9015a8497d6f8da85e1179812cc8585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStorageManager_1_1Array.html">Array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ae9015a8497d6f8da85e1179812cc8585">array_</a></td></tr>
<tr class="separator:ae9015a8497d6f8da85e1179812cc8585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab52d06b20baffddb47cf89c80e17c7de"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ab52d06b20baffddb47cf89c80e17c7de">attribute_ids_</a></td></tr>
<tr class="separator:ab52d06b20baffddb47cf89c80e17c7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae35803cb3730571ee9f86f09fe941"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ae2ae35803cb3730571ee9f86f09fe941">attribute_num_</a></td></tr>
<tr class="separator:ae2ae35803cb3730571ee9f86f09fe941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80af6f1e1e74dd28172ba6f5500289fb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a80af6f1e1e74dd28172ba6f5500289fb">cell_</a></td></tr>
<tr class="separator:a80af6f1e1e74dd28172ba6f5500289fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f58978cc17b0bcf4d498915a5cca1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTile_1_1const__reverse__cell__iterator.html">Tile::const_reverse_cell_iterator</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ad4f58978cc17b0bcf4d498915a5cca1b">cell_its_</a></td></tr>
<tr class="separator:ad4f58978cc17b0bcf4d498915a5cca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af073bd6ff65c84ead2a53b23cf6ddf65"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#af073bd6ff65c84ead2a53b23cf6ddf65">cell_size_</a></td></tr>
<tr class="separator:af073bd6ff65c84ead2a53b23cf6ddf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9070d214b7a1b7d5b419dbd2d0bfb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a0b9070d214b7a1b7d5b419dbd2d0bfb6">dim_num_</a></td></tr>
<tr class="separator:a0b9070d214b7a1b7d5b419dbd2d0bfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053deba563ae436f07b1c7c111aff8ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a053deba563ae436f07b1c7c111aff8ab">end_</a></td></tr>
<tr class="separator:a053deba563ae436f07b1c7c111aff8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea5fedc37a655e9dd65e471171c0266"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a7ea5fedc37a655e9dd65e471171c0266">fragment_ids_</a></td></tr>
<tr class="separator:a7ea5fedc37a655e9dd65e471171c0266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1261d5ce3cade89ea94751531325dff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a1261d5ce3cade89ea94751531325dff4">fragment_num_</a></td></tr>
<tr class="separator:a1261d5ce3cade89ea94751531325dff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2b6034087c122241059f16bf6131b1"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#aad2b6034087c122241059f16bf6131b1">full_overlap_</a></td></tr>
<tr class="separator:aad2b6034087c122241059f16bf6131b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e2b057d538114638ac0ac0476a8ba8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ae3e2b057d538114638ac0ac0476a8ba8">is_del_</a></td></tr>
<tr class="separator:ae3e2b057d538114638ac0ac0476a8ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bad4e1e24814785b6ddca558735a24"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#af6bad4e1e24814785b6ddca558735a24">range_</a></td></tr>
<tr class="separator:af6bad4e1e24814785b6ddca558735a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de3135fe63b39f73d699a79d773828a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a2de3135fe63b39f73d699a79d773828a">return_del_</a></td></tr>
<tr class="separator:a2de3135fe63b39f73d699a79d773828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ec6eabf371f96e8b91d101f8e17675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStorageManager_1_1Fragment_1_1const__reverse__tile__iterator.html">Fragment::const_reverse_tile_iterator</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#ad3ec6eabf371f96e8b91d101f8e17675">tile_its_</a></td></tr>
<tr class="separator:ad3ec6eabf371f96e8b91d101f8e17675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605db1ee1adf195b8c846e65a730c025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html#a605db1ee1adf195b8c846e65a730c025">var_size_</a></td></tr>
<tr class="separator:a605db1ee1adf195b8c846e65a730c025"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class StorageManager::Array::const_reverse_cell_iterator&lt; T &gt;</h3>

<p>A constant reverse cell iterator that iterates over the cells of all the fragments of the array in the global cell order as specified by the array schema. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a39c494e646fcc4700dc301229665eb22"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a7778814f01a6600067edba1e6b3d710e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1Array.html">Array</a> *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a3243c47a5b32b9e242cf024480dc7eb4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1Array.html">Array</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>fragment_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. The second argument specifies the fragments the iterator will focus on. If the list is empty, then the iterator iterates over all fragments. The last argument indicates whether a cell representing a deletion must be returned or suppressed. </p>

</div>
</div>
<a class="anchor" id="add2de2158ea0892c3d47e6854f92a97f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1Array.html">Array</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. The second argument determines the attribute the iterator will focus on. </p>

</div>
</div>
<a class="anchor" id="afcf9e32d2a0ba1eeb3f5543ed6db62e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1Array.html">Array</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes as input also a multi-dimensional range. The iterator will iterate only on the cells of the array whose coordinates fall into the input range. </p>

</div>
</div>
<a class="anchor" id="ae041950dda2fe99f8a3d9aa0211da613"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1Array.html">Array</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>attribute_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes as input also a multi-dimensional range. The iterator will iterate only on the cells of the array whose coordinates fall into the input range. The third argument determines the attributes the iterator will focus on. </p>

</div>
</div>
<a class="anchor" id="a1e64ec535427e572be20d364f25d04dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::~<a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">const_reverse_cell_iterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aedaabb27f3c800ec4aee8fb1ee917b51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::advance_cell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fragment_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advances the cell iterators of all attributes of the fragment with the input id. </p>

</div>
</div>
<a class="anchor" id="aa36d101497be184e263d5a23774c974b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::advance_cell_in_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fragment_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advances the cell iterators of all attributes of the fragment with the input id, until the next cell in range is found. </p>

</div>
</div>
<a class="anchor" id="ad4e0c39197231c45db9faead252c2dd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;int&gt;&amp; <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::attribute_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ids of the attributes the iterator iterates on. </p>

</div>
</div>
<a class="anchor" id="ad1017ce348c44bb7623a8ad36b28bf92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::cell_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the current cell. </p>

</div>
</div>
<a class="anchor" id="aa8438b91cf2d63197c84544a6afe8f9b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::cell_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fragment_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the current cell pointed by the iterators of the fragment with id equal to fragment_id. </p>

</div>
</div>
<a class="anchor" id="a97475a3e5aa93f64f9962d5dc39ff9f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the iterator has reached the end of the cells. </p>

</div>
</div>
<a class="anchor" id="ac6f63d1b1b268e5c3727d5df4395a94d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::find_next_cell_in_range </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fragment_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the next cell from the input fragment along the global cell order, which falls inside the range stored upon initialization of the iterator (see <a class="el" href="classStorageManager_1_1Array_1_1const__cell__iterator.html#abe48759f70358627df97e3aaec3fe8fd">StorageManager::Array::const_cell_iterator::range_</a>). </p>

</div>
</div>
<a class="anchor" id="a49f2ee1cea305bd1c4e3e939d191efa1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::get_next_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extracts the next cell from all the fragments along the global cell order. It returns the id of the fragment the cell was extracted from. If the end of the cells is reached, it returns -1. </p>

</div>
</div>
<a class="anchor" id="a0757d5ce0f03b978172a40b6d910dd25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::init_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes tile and cell iterators for the input fragments and attributes. </p>

</div>
</div>
<a class="anchor" id="aa029ee5fd04ddd1ba94f866a54c7870c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::init_iterators_in_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes tile and cell iterators that will irerate over tiles and cells that overlap with the stored range. </p>

</div>
</div>
<a class="anchor" id="a477673a8462e6aa41d4ed8c8078dcd46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const void* <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dereference. </p>

</div>
</div>
<a class="anchor" id="abb79b3277f6e49a03c0673c774c3c123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increment. </p>

</div>
</div>
<a class="anchor" id="a3a783504da48f6577a2ad5d1db556aed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::precedes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTile_1_1const__reverse__cell__iterator.html">Tile::const_reverse_cell_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTile_1_1const__reverse__cell__iterator.html">Tile::const_reverse_cell_iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if the cell pointed by the first iterator precedes that of the second on the global cell order. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae9015a8497d6f8da85e1179812cc8585"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Array.html">Array</a>* <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::array_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array the cell iterator was created for. </p>

</div>
</div>
<a class="anchor" id="ab52d06b20baffddb47cf89c80e17c7de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::attribute_ids_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ids of the attributes the iterator iterates over. </p>

</div>
</div>
<a class="anchor" id="ae2ae35803cb3730571ee9f86f09fe941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::attribute_num_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of attributes. </p>

</div>
</div>
<a class="anchor" id="a80af6f1e1e74dd28172ba6f5500289fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::cell_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current cell. Contains pointers to physical cells of all attibutes. </p>

</div>
</div>
<a class="anchor" id="ad4f58978cc17b0bcf4d498915a5cca1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTile_1_1const__reverse__cell__iterator.html">Tile::const_reverse_cell_iterator</a>** <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::cell_its_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores one cell iterator per fragment per attribute. </p>

</div>
</div>
<a class="anchor" id="af073bd6ff65c84ead2a53b23cf6ddf65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::cell_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The size of the current cell. </p>

</div>
</div>
<a class="anchor" id="a0b9070d214b7a1b7d5b419dbd2d0bfb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::dim_num_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of dimensions. </p>

</div>
</div>
<a class="anchor" id="a053deba563ae436f07b1c7c111aff8ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::end_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if the iterator has reached the end of all cells. </p>

</div>
</div>
<a class="anchor" id="a7ea5fedc37a655e9dd65e471171c0266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::fragment_ids_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The ids of the fragments the iterator iterates over. </p>

</div>
</div>
<a class="anchor" id="a1261d5ce3cade89ea94751531325dff4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::fragment_num_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of fragments. </p>

</div>
</div>
<a class="anchor" id="aad2b6034087c122241059f16bf6131b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::full_overlap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a value per fragment. It is used when iterating cells that fall inside the stored range. It indicates whether the current logical tile under investigation is completely contained in the range or not. </p>

</div>
</div>
<a class="anchor" id="ae3e2b057d538114638ac0ac0476a8ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::is_del_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if the cell currently pointed to by the iterator represents a deletion. </p>

</div>
</div>
<a class="anchor" id="af6bad4e1e24814785b6ddca558735a24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::range_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A multi-dimensional range. If not NULL, the iterator will iterate only on the cells of the array whose coordinates fall into the input range. </p>

</div>
</div>
<a class="anchor" id="a2de3135fe63b39f73d699a79d773828a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::return_del_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If true, a cell representing a deletion must be returned, otherwise it is suppressed. </p>

</div>
</div>
<a class="anchor" id="ad3ec6eabf371f96e8b91d101f8e17675"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Fragment_1_1const__reverse__tile__iterator.html">Fragment::const_reverse_tile_iterator</a>** <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::tile_its_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores one tile iterator per fragment per attribute. </p>

</div>
</div>
<a class="anchor" id="a605db1ee1adf195b8c846e65a730c025"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classStorageManager_1_1Array_1_1const__reverse__cell__iterator.html">StorageManager::Array::const_reverse_cell_iterator</a>&lt; T &gt;::var_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if the iterator iterates over variable-sized cells. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/include/<a class="el" href="storage__manager_8h_source.html">storage_manager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 10 2015 15:04:03 for TileDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
