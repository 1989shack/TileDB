<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TileDB: Executor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TileDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classExecutor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Executor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="executor_8h_source.html">executor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ea6a42d8c97cb71e5720830af349954"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a5ea6a42d8c97cb71e5720830af349954">Executor</a> (std::string workspace)</td></tr>
<tr class="separator:a5ea6a42d8c97cb71e5720830af349954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23108c89c4a25e22c927115191c04b26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a23108c89c4a25e22c927115191c04b26">~Executor</a> ()</td></tr>
<tr class="separator:a23108c89c4a25e22c927115191c04b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45648f4d114834e3f1abac2d3b89c580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a45648f4d114834e3f1abac2d3b89c580">clear_array</a> (const std::string &amp;array_name) const </td></tr>
<tr class="separator:a45648f4d114834e3f1abac2d3b89c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9429d0df8f4fb4b055ac9a775527b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a4f9429d0df8f4fb4b055ac9a775527b7">close_array</a> (const StorageManager::ArrayDescriptor *ad) const </td></tr>
<tr class="separator:a4f9429d0df8f4fb4b055ac9a775527b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adf42d9015146cb8cd8d0b7c8911597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a6adf42d9015146cb8cd8d0b7c8911597">close_fragment</a> (StorageManager::FragmentDescriptor *fd) const </td></tr>
<tr class="separator:a6adf42d9015146cb8cd8d0b7c8911597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb431db3659ae76d9d308fa135b73a5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#adb431db3659ae76d9d308fa135b73a5e">define_array</a> (const <a class="el" href="classArraySchema.html">ArraySchema</a> *array_schema) const </td></tr>
<tr class="separator:adb431db3659ae76d9d308fa135b73a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abf0d9cee895dfec60d701c0bc93599"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a5abf0d9cee895dfec60d701c0bc93599">delete_array</a> (const std::string &amp;array_name) const </td></tr>
<tr class="separator:a5abf0d9cee895dfec60d701c0bc93599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e63010bb79b43baa8a2cbe60dfd961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#af2e63010bb79b43baa8a2cbe60dfd961">export_to_csv</a> (const std::string &amp;array_name, const std::string &amp;filename) const </td></tr>
<tr class="separator:af2e63010bb79b43baa8a2cbe60dfd961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0486a017c19e392e2a14f4050374f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a1c0486a017c19e392e2a14f4050374f5">file_exists</a> (const std::string &amp;filename) const </td></tr>
<tr class="separator:a1c0486a017c19e392e2a14f4050374f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164b2b522121abae3a0adc5da5e035f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a164b2b522121abae3a0adc5da5e035f3">filter</a> (const std::string &amp;array_name, const std::string &amp;expression, const std::string &amp;result_array_name) const </td></tr>
<tr class="separator:a164b2b522121abae3a0adc5da5e035f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867550d21cbde880c10f114f3920f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a6867550d21cbde880c10f114f3920f79">join</a> (const std::string &amp;array_name_A, const std::string &amp;array_name_B, const std::string &amp;result_array_name) const </td></tr>
<tr class="separator:a6867550d21cbde880c10f114f3920f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34a362db8c55b14a6b71424f18467d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ac34a362db8c55b14a6b71424f18467d2">load</a> (const std::string &amp;filename, const std::string &amp;array_name) const </td></tr>
<tr class="separator:ac34a362db8c55b14a6b71424f18467d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda8766b3b5d866816b30d85a6b138f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a0cda8766b3b5d866816b30d85a6b138f">load_array_schema</a> (const std::string &amp;array_name) const </td></tr>
<tr class="separator:a0cda8766b3b5d866816b30d85a6b138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f20edeb99f4e8fbd8e78a05293d17f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ad3f20edeb99f4e8fbd8e78a05293d17f">nearest_neighbors</a> (const std::string &amp;array_name, const std::vector&lt; double &gt; &amp;q, int64_t k, const std::string &amp;result_array_name) const </td></tr>
<tr class="separator:ad3f20edeb99f4e8fbd8e78a05293d17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905abc2da523e6a765c80739c1e64eaf"><td class="memItemLeft" align="right" valign="top">const StorageManager::ArrayDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a905abc2da523e6a765c80739c1e64eaf">open_array</a> (const <a class="el" href="classArraySchema.html">ArraySchema</a> *array_schema) const </td></tr>
<tr class="separator:a905abc2da523e6a765c80739c1e64eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72b90048461a0a224ddc704e0aa23bd"><td class="memItemLeft" align="right" valign="top">StorageManager::FragmentDescriptor *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ab72b90048461a0a224ddc704e0aa23bd">open_fragment</a> (const <a class="el" href="classArraySchema.html">ArraySchema</a> *array_schema) const </td></tr>
<tr class="separator:ab72b90048461a0a224ddc704e0aa23bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85565a2aa21cfd832bf5f8ad0be7026a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a85565a2aa21cfd832bf5f8ad0be7026a">read</a> (const StorageManager::ArrayDescriptor *ad, int attribute_id, const void *range, void *&amp;coords, size_t &amp;coords_size, void *&amp;attrs, size_t &amp;attrs_size) const </td></tr>
<tr class="separator:a85565a2aa21cfd832bf5f8ad0be7026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7406e279c2fbdd1f6b4a8c1e9aeed61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ac7406e279c2fbdd1f6b4a8c1e9aeed61">retile</a> (const std::string &amp;array_name, int64_t capacity, <a class="el" href="classArraySchema.html#a847601130253f905337b5e284e1b78f2">ArraySchema::CellOrder</a> cell_order, const std::vector&lt; double &gt; &amp;tile_extents) const </td></tr>
<tr class="separator:ac7406e279c2fbdd1f6b4a8c1e9aeed61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b14f1a0748cc2950eb300b45419f6b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a6b14f1a0748cc2950eb300b45419f6b6">subarray</a> (const std::string &amp;array_name, const double *range, const std::string &amp;result_array_name) const </td></tr>
<tr class="separator:a6b14f1a0748cc2950eb300b45419f6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae147e4a5668cdfbcefecccdae19334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#adae147e4a5668cdfbcefecccdae19334">update</a> (const std::string &amp;filename, const std::string &amp;array_name) const </td></tr>
<tr class="separator:adae147e4a5668cdfbcefecccdae19334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a7f583b63cebbe2a4b056562006633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ad4a7f583b63cebbe2a4b056562006633">write</a> (StorageManager::FragmentDescriptor *fd, void *coords, size_t coords_size, void *attrs, size_t attrs_size) const </td></tr>
<tr class="separator:ad4a7f583b63cebbe2a4b056562006633"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ace6488bc7140a974f82232c50469d590"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ace6488bc7140a974f82232c50469d590">get_all_fragment_names</a> (const <a class="el" href="classArraySchema.html">ArraySchema</a> *array_schema) const </td></tr>
<tr class="separator:ace6488bc7140a974f82232c50469d590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af6b19b60d913bdb5eb2038640a0004"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a0af6b19b60d913bdb5eb2038640a0004">path_exists</a> (const std::string &amp;path) const </td></tr>
<tr class="separator:a0af6b19b60d913bdb5eb2038640a0004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3e2b0b4be9e268745001efc43ffbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a3a3e2b0b4be9e268745001efc43ffbd4">set_workspace</a> (const std::string &amp;path)</td></tr>
<tr class="separator:a3a3e2b0b4be9e268745001efc43ffbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f3c192d8031a94b256829aaf09b867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a47f3c192d8031a94b256829aaf09b867">update_fragment_info</a> (const <a class="el" href="classArraySchema.html">ArraySchema</a> *array_schema) const </td></tr>
<tr class="separator:a47f3c192d8031a94b256829aaf09b867"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa9659d47bccbe09cdd01357712bca7e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConsolidator.html">Consolidator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#aa9659d47bccbe09cdd01357712bca7e2">consolidator_</a></td></tr>
<tr class="separator:aa9659d47bccbe09cdd01357712bca7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4939f1b29639e263d50da6436c24bff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLoader.html">Loader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a4939f1b29639e263d50da6436c24bff6">loader_</a></td></tr>
<tr class="separator:a4939f1b29639e263d50da6436c24bff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f7004773177d4dd47ca0a3f32d4f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classQueryProcessor.html">QueryProcessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a83f7004773177d4dd47ca0a3f32d4f89">query_processor_</a></td></tr>
<tr class="separator:a83f7004773177d4dd47ca0a3f32d4f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cbe36555c96a8d5efde76a542acd92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStorageManager.html">StorageManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#ae8cbe36555c96a8d5efde76a542acd92">storage_manager_</a></td></tr>
<tr class="separator:ae8cbe36555c96a8d5efde76a542acd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acb7687ad0865b90cb77f3290482d8b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExecutor.html#a6acb7687ad0865b90cb77f3290482d8b">workspace_</a></td></tr>
<tr class="separator:a6acb7687ad0865b90cb77f3290482d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classExecutor.html">Executor</a> is responsible for receiving the user queries and dispatching them to the appropriate modules (e.g., the <a class="el" href="classLoader.html">Loader</a>, the <a class="el" href="classConsolidator.html">Consolidator</a>, and the <a class="el" href="classQueryProcessor.html">QueryProcessor</a>). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5ea6a42d8c97cb71e5720830af349954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor::Executor </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>workspace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple constructor. </p>

</div>
</div>
<a class="anchor" id="a23108c89c4a25e22c927115191c04b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Executor::~Executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The destructor deletes all the created modules. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a45648f4d114834e3f1abac2d3b89c580"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::clear_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all the fragments of the array. </p>

</div>
</div>
<a class="anchor" id="a4f9429d0df8f4fb4b055ac9a775527b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::close_array </td>
          <td>(</td>
          <td class="paramtype">const StorageManager::ArrayDescriptor *&#160;</td>
          <td class="paramname"><em>ad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes an array. </p>

</div>
</div>
<a class="anchor" id="a6adf42d9015146cb8cd8d0b7c8911597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::close_fragment </td>
          <td>(</td>
          <td class="paramtype">StorageManager::FragmentDescriptor *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes a fragment. </p>

</div>
</div>
<a class="anchor" id="adb431db3659ae76d9d308fa135b73a5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::define_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines an array (stores its array schema at the storage manager. </p>

</div>
</div>
<a class="anchor" id="a5abf0d9cee895dfec60d701c0bc93599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::delete_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes an array. </p>

</div>
</div>
<a class="anchor" id="af2e63010bb79b43baa8a2cbe60dfd961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::export_to_csv </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports an array to a CSV file. Each line in the CSV file represents a logical cell comprised of coordinates and attribute values. The coordinates are written first, and then the attribute values, following the order as defined in the schema of the array. </p>

</div>
</div>
<a class="anchor" id="a1c0486a017c19e392e2a14f4050374f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Executor::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the input file exists. </p>

</div>
</div>
<a class="anchor" id="a164b2b522121abae3a0adc5da5e035f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::filter </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A filter query creates a new array from the input array, containing only the cells whose attribute values satisfy the input expression. The new array will have the input result name. </p>

</div>
</div>
<a class="anchor" id="ace6488bc7140a974f82232c50469d590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Executor::get_all_fragment_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the names of all fragments in the array. </p>

</div>
</div>
<a class="anchor" id="a6867550d21cbde880c10f114f3920f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Joins the two input arrays (say, A and B). The result contains a cell only if both the corresponding cells in A and B are non-empty. The input arrays must be join-compatible (see <a class="el" href="classArraySchema.html#a07cd6246c8275fbaa0e11adad15dd63a">ArraySchema::join_compatible</a>). Moreover, see <a class="el" href="classArraySchema.html#a043a7a6b37d93748b8acd90f4eebb579">ArraySchema::create_join_result_schema</a> to see the schema of the output array. </p>

</div>
</div>
<a class="anchor" id="ac34a362db8c55b14a6b71424f18467d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a CSV file into an array. </p>

</div>
</div>
<a class="anchor" id="a0cda8766b3b5d866816b30d85a6b138f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArraySchema.html">ArraySchema</a>* Executor::load_array_schema </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array schema. </p>

</div>
</div>
<a class="anchor" id="ad3f20edeb99f4e8fbd8e78a05293d17f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::nearest_neighbors </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the k nearest neighbors from query point q. The results (along with all their attribute values) are stored in a new array. The distance metric used to calculate proximity is the Euclidean distance. </p>

</div>
</div>
<a class="anchor" id="a905abc2da523e6a765c80739c1e64eaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const StorageManager::ArrayDescriptor* Executor::open_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens an array in READ mode and returns the corresponding descriptor. </p>

</div>
</div>
<a class="anchor" id="ab72b90048461a0a224ddc704e0aa23bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageManager::FragmentDescriptor* Executor::open_fragment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens an array fragment in WRITE mode and returns the corresponding descriptor. </p>

</div>
</div>
<a class="anchor" id="a0af6b19b60d913bdb5eb2038640a0004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Executor::path_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the input path is an existing directory. </p>

</div>
</div>
<a class="anchor" id="a85565a2aa21cfd832bf5f8ad0be7026a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::read </td>
          <td>(</td>
          <td class="paramtype">const StorageManager::ArrayDescriptor *&#160;</td>
          <td class="paramname"><em>ad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>coords_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>attrs_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the coordinates of the non-empty cells of the input array falling inside the input range into the coords buffer, and their corresponding attribute values on the input attribute into buffer values, setting properly the buffer sizes in bytes. </p>

</div>
</div>
<a class="anchor" id="ac7406e279c2fbdd1f6b4a8c1e9aeed61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::retile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArraySchema.html#a847601130253f905337b5e284e1b78f2">ArraySchema::CellOrder</a>&#160;</td>
          <td class="paramname"><em>cell_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>tile_extents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retiles an array based on the inputs. If tile extents are provided (i) in the case of regular tiles, if the extents differ from those in the array schema, retiling occurs, (ii) in the case of irregular tiles, the array is retiled so that it has regular tiles. If tile extents are not provided for the case of regular tiles, the array is retiled to one with irregular tiles. If order is provided (different from the existing order) retiling occurs. If a capacity is provided, (i) in the case of regular tiles it has no effect (only the schema changes), (ii) in the case of irregular tiles, only the book-keeping structures and array schema are altered to accommodate the change. </p>

</div>
</div>
<a class="anchor" id="a3a3e2b0b4be9e268745001efc43ffbd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::set_workspace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simply sets the workspace. </p>

</div>
</div>
<a class="anchor" id="a6b14f1a0748cc2950eb300b45419f6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::subarray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>result_array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A subarray query creates a new array from the input array, containing only the cells whose coordinates fall into the input range. The new array will have the input result name. </p>

</div>
</div>
<a class="anchor" id="adae147e4a5668cdfbcefecccdae19334"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::update </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates an array with the data in the input CSV file. </p>

</div>
</div>
<a class="anchor" id="a47f3c192d8031a94b256829aaf09b867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::update_fragment_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the fragment information (adding one fragment) of an array. </p>

</div>
</div>
<a class="anchor" id="ad4a7f583b63cebbe2a4b056562006633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Executor::write </td>
          <td>(</td>
          <td class="paramtype">StorageManager::FragmentDescriptor *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>coords_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attrs_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the input coordinates and attributess into an array. The input cells do not respect the global cell order. NOTE: The input buffers will be freed by the function. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa9659d47bccbe09cdd01357712bca7e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConsolidator.html">Consolidator</a>* Executor::consolidator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classConsolidator.html">Consolidator</a> module. </p>

</div>
</div>
<a class="anchor" id="a4939f1b29639e263d50da6436c24bff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLoader.html">Loader</a>* Executor::loader_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classLoader.html">Loader</a> module. </p>

</div>
</div>
<a class="anchor" id="a83f7004773177d4dd47ca0a3f32d4f89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQueryProcessor.html">QueryProcessor</a>* Executor::query_processor_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classQueryProcessor.html">QueryProcessor</a> module. </p>

</div>
</div>
<a class="anchor" id="ae8cbe36555c96a8d5efde76a542acd92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager.html">StorageManager</a>* Executor::storage_manager_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classStorageManager.html">StorageManager</a> module. </p>

</div>
</div>
<a class="anchor" id="a6acb7687ad0865b90cb77f3290482d8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Executor::workspace_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A folder in the disk where the <a class="el" href="classExecutor.html">Executor</a> creates all its data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/include/<a class="el" href="executor_8h_source.html">executor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Apr 7 2015 16:57:46 for TileDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
