<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TileDB: StorageManager::Fragment Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TileDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="classStorageManager.html">StorageManager</a></li><li class="navelem"><a class="el" href="classStorageManager_1_1Fragment.html">Fragment</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classStorageManager_1_1Fragment-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StorageManager::Fragment Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="storage__manager_8h_source.html">storage_manager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment_1_1const__reverse__tile__iterator.html">const_reverse_tile_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment_1_1const__tile__iterator.html">const_tile_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48e2456338d3271c094815d3e11f43b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a48e2456338d3271c094815d3e11f43b5">Fragment</a> (const std::string &amp;workspace, size_t segment_size, size_t write_state_max_size, const <a class="el" href="classArraySchema.html">ArraySchema</a> *<a class="el" href="classStorageManager_1_1Fragment.html#a1d213b136596a6b756b7cd27e3f1b5de">array_schema</a>, const std::string &amp;<a class="el" href="classStorageManager_1_1Fragment.html#ac0d3522c8b7572b4d378843486e9a81c">fragment_name</a>)</td></tr>
<tr class="separator:a48e2456338d3271c094815d3e11f43b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47c68b3770e0334954620557f021769"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac47c68b3770e0334954620557f021769">~Fragment</a> ()</td></tr>
<tr class="separator:ac47c68b3770e0334954620557f021769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d213b136596a6b756b7cd27e3f1b5de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a1d213b136596a6b756b7cd27e3f1b5de">array_schema</a> () const </td></tr>
<tr class="separator:a1d213b136596a6b756b7cd27e3f1b5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d3522c8b7572b4d378843486e9a81c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac0d3522c8b7572b4d378843486e9a81c">fragment_name</a> () const </td></tr>
<tr class="separator:ac0d3522c8b7572b4d378843486e9a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c43fd9d6fde012a35fe00e1ea569c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a00c43fd9d6fde012a35fe00e1ea569c4">write_cell</a> (const <a class="el" href="structStorageManager_1_1Cell.html">StorageManager::Cell</a> &amp;cell, size_t cell_size)</td></tr>
<tr class="separator:a00c43fd9d6fde012a35fe00e1ea569c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315b1953363fe48f7d488251d3467b36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a315b1953363fe48f7d488251d3467b36">write_cell</a> (const <a class="el" href="structStorageManager_1_1CellWithId.html">StorageManager::CellWithId</a> &amp;cell, size_t cell_size)</td></tr>
<tr class="separator:a315b1953363fe48f7d488251d3467b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c91628918a91a39e16e661097f8b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a05c91628918a91a39e16e661097f8b27">write_cell</a> (const <a class="el" href="structStorageManager_1_1CellWith2Ids.html">StorageManager::CellWith2Ids</a> &amp;cell, size_t cell_size)</td></tr>
<tr class="separator:a05c91628918a91a39e16e661097f8b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c4e22eeeadac8fc485852c4b7cba8d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a93c4e22eeeadac8fc485852c4b7cba8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a93c4e22eeeadac8fc485852c4b7cba8d">write_cell_sorted</a> (const void *cell)</td></tr>
<tr class="separator:a93c4e22eeeadac8fc485852c4b7cba8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ccba2bf546801841600dfbec98fe93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae8ccba2bf546801841600dfbec98fe93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ae8ccba2bf546801841600dfbec98fe93">write_cell_sorted_with_id</a> (const void *cell)</td></tr>
<tr class="separator:ae8ccba2bf546801841600dfbec98fe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fd646ac3d5a604a2bcdcdf6b1f79c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa5fd646ac3d5a604a2bcdcdf6b1f79c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#aa5fd646ac3d5a604a2bcdcdf6b1f79c6">write_cell_sorted_with_2_ids</a> (const void *cell)</td></tr>
<tr class="separator:aa5fd646ac3d5a604a2bcdcdf6b1f79c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a75d16440c30799c494260aaae21986"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTile.html">Tile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a8a75d16440c30799c494260aaae21986">get_tile_by_pos</a> (int attribute_id, int64_t pos)</td></tr>
<tr class="separator:a8a75d16440c30799c494260aaae21986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366b8644d06b35c575847e9e681a42eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTile.html">Tile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a366b8644d06b35c575847e9e681a42eb">rget_tile_by_pos</a> (int attribute_id, int64_t pos)</td></tr>
<tr class="separator:a366b8644d06b35c575847e9e681a42eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77980a66c33881ac0d46ac5747dd759e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a77980a66c33881ac0d46ac5747dd759e">tile_num</a> () const </td></tr>
<tr class="separator:a77980a66c33881ac0d46ac5747dd759e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a88e321a7bfab562796e5ce239cee1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a56a88e321a7bfab562796e5ce239cee1">tile_size</a> (int attribute_id, int64_t pos) const </td></tr>
<tr class="separator:a56a88e321a7bfab562796e5ce239cee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70af51da34a52acc74c8234f292746f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStorageManager_1_1Fragment_1_1const__tile__iterator.html">const_tile_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a70af51da34a52acc74c8234f292746f9">begin</a> (int attribute_id)</td></tr>
<tr class="separator:a70af51da34a52acc74c8234f292746f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a5d0fa8938b7ee9f8ce15dadccfc2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStorageManager_1_1Fragment_1_1const__reverse__tile__iterator.html">const_reverse_tile_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ad5a5d0fa8938b7ee9f8ce15dadccfc2a">rbegin</a> (int attribute_id)</td></tr>
<tr class="separator:ad5a5d0fa8938b7ee9f8ce15dadccfc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a67e10e1748161a55d0c75b0b19a58dd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a67e10e1748161a55d0c75b0b19a58dd7">operator delete</a> (void *ptr)</td></tr>
<tr class="separator:a67e10e1748161a55d0c75b0b19a58dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f0de60e42ac71a1b12be222c497f1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a65f0de60e42ac71a1b12be222c497f1c">operator delete[]</a> (void *ptr)</td></tr>
<tr class="separator:a65f0de60e42ac71a1b12be222c497f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06065659ce3af9a4f1929df73079065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ab06065659ce3af9a4f1929df73079065">clear_read_state</a> ()</td></tr>
<tr class="separator:ab06065659ce3af9a4f1929df73079065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae64ed0524836f04f8dcb4b5d8b209e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#aae64ed0524836f04f8dcb4b5d8b209e7">delete_tiles</a> (int attribute_id)</td></tr>
<tr class="separator:aae64ed0524836f04f8dcb4b5d8b209e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da2ac08f8dfbc96b293e58cbff0ef8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ab0da2ac08f8dfbc96b293e58cbff0ef8">init_read_state</a> ()</td></tr>
<tr class="separator:ab0da2ac08f8dfbc96b293e58cbff0ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64075a2c6dfd3b3c9c397dd418e3a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ae64075a2c6dfd3b3c9c397dd418e3a9a">load_sorted_bin</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:ae64075a2c6dfd3b3c9c397dd418e3a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de2c4f4eedc861cd970923c06d82b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a1de2c4f4eedc861cd970923c06d82b58">load_tiles_from_disk</a> (int attribute_id, int64_t pos)</td></tr>
<tr class="separator:a1de2c4f4eedc861cd970923c06d82b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99159a6ae39e50637e6d3568ff9be9e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a99159a6ae39e50637e6d3568ff9be9e6">load_tiles_from_segment</a> (int attribute_id, int64_t pos, size_t segment_utilization, int64_t tiles_in_segment)</td></tr>
<tr class="separator:a99159a6ae39e50637e6d3568ff9be9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba7c45a9ffbb5989b96d10cf6dc256d"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a1ba7c45a9ffbb5989b96d10cf6dc256d">load_payloads_into_segment</a> (int attribute_id, int64_t pos)</td></tr>
<tr class="separator:a1ba7c45a9ffbb5989b96d10cf6dc256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6d9eb7854658f88dbc09f5455433d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a3d6d9eb7854658f88dbc09f5455433d7">append_attribute_to_segment</a> (const char *attr, int attribute_id, size_t &amp;attr_size)</td></tr>
<tr class="separator:a3d6d9eb7854658f88dbc09f5455433d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50b4d47ac08eca95adb05e010290874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#af50b4d47ac08eca95adb05e010290874">append_coordinates_to_segment</a> (const char *coords)</td></tr>
<tr class="separator:af50b4d47ac08eca95adb05e010290874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fe4b3e77c03a9665265f0e2a8468b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a87fe4b3e77c03a9665265f0e2a8468b8">clear_write_state</a> ()</td></tr>
<tr class="separator:a87fe4b3e77c03a9665265f0e2a8468b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6054177999ae03f64c403a98bcffb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a1c6054177999ae03f64c403a98bcffb4">finalize_last_run</a> ()</td></tr>
<tr class="separator:a1c6054177999ae03f64c403a98bcffb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5a6c47e126e446c1360cd56200f6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a1a5a6c47e126e446c1360cd56200f6c8">flush_segment</a> (int attribute_id)</td></tr>
<tr class="separator:a1a5a6c47e126e446c1360cd56200f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24534aab0c30c3ad4e698f7b3616551"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#af24534aab0c30c3ad4e698f7b3616551">flush_segments</a> ()</td></tr>
<tr class="separator:af24534aab0c30c3ad4e698f7b3616551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d59f0dbb25439d2d815fcb1ce5f8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a041d59f0dbb25439d2d815fcb1ce5f8a">flush_sorted_run</a> ()</td></tr>
<tr class="separator:a041d59f0dbb25439d2d815fcb1ce5f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71370dc250d104ac47923ef9cbafb9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a71370dc250d104ac47923ef9cbafb9e2">flush_sorted_run_with_id</a> ()</td></tr>
<tr class="separator:a71370dc250d104ac47923ef9cbafb9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7113f64fcab841248023faa67006b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#afc7113f64fcab841248023faa67006b2">flush_sorted_run_with_2_ids</a> ()</td></tr>
<tr class="separator:afc7113f64fcab841248023faa67006b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59edd2ba1f571d176f3bd3edfaa25aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#aa59edd2ba1f571d176f3bd3edfaa25aa">flush_tile_info_to_book_keeping</a> ()</td></tr>
<tr class="separator:aa59edd2ba1f571d176f3bd3edfaa25aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6174b7f9a3563b75171604ec699d365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#af6174b7f9a3563b75171604ec699d365">flush_write_state</a> ()</td></tr>
<tr class="separator:af6174b7f9a3563b75171604ec699d365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ccd449a820cea6b30629ced081e597"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87ccd449a820cea6b30629ced081e597"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a87ccd449a820cea6b30629ced081e597">get_next_cell</a> (<a class="el" href="classStorageManager_1_1SortedRun.html">SortedRun</a> **runs, int runs_num, size_t &amp;cell_size) const </td></tr>
<tr class="separator:a87ccd449a820cea6b30629ced081e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa066f5d08c4d147fd1061315aabc2be"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afa066f5d08c4d147fd1061315aabc2be"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#afa066f5d08c4d147fd1061315aabc2be">get_next_cell_with_id</a> (<a class="el" href="classStorageManager_1_1SortedRun.html">SortedRun</a> **runs, int runs_num, size_t &amp;cell_size) const </td></tr>
<tr class="separator:afa066f5d08c4d147fd1061315aabc2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b3756bb279e40a64e10813714ea254"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a56b3756bb279e40a64e10813714ea254"><td class="memTemplItemLeft" align="right" valign="top">void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a56b3756bb279e40a64e10813714ea254">get_next_cell_with_2_ids</a> (<a class="el" href="classStorageManager_1_1SortedRun.html">SortedRun</a> **runs, int runs_num, size_t &amp;cell_size) const </td></tr>
<tr class="separator:a56b3756bb279e40a64e10813714ea254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d50f4c7196b31fb28b1b2ce3647660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a73d50f4c7196b31fb28b1b2ce3647660">init_write_state</a> ()</td></tr>
<tr class="separator:a73d50f4c7196b31fb28b1b2ce3647660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157d23b2daea63bca4d6b04887392982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a157d23b2daea63bca4d6b04887392982">make_tiles</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:a157d23b2daea63bca4d6b04887392982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb664e2edf5cf432db548093396d2bd3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abb664e2edf5cf432db548093396d2bd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#abb664e2edf5cf432db548093396d2bd3">make_tiles</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:abb664e2edf5cf432db548093396d2bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccdfdf74d69ca5a99f252b9fdd0b351"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ccdfdf74d69ca5a99f252b9fdd0b351"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a2ccdfdf74d69ca5a99f252b9fdd0b351">make_tiles_with_id</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:a2ccdfdf74d69ca5a99f252b9fdd0b351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c16b86455f3dbb6d2fcd226ea726523"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9c16b86455f3dbb6d2fcd226ea726523"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a9c16b86455f3dbb6d2fcd226ea726523">make_tiles_with_2_ids</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:a9c16b86455f3dbb6d2fcd226ea726523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787d513d7fd01c024cb7a8c3fad21ff5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a787d513d7fd01c024cb7a8c3fad21ff5">merge_sorted_runs</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:a787d513d7fd01c024cb7a8c3fad21ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac787db9fd103d0ee5a067eab5ea4c297"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac787db9fd103d0ee5a067eab5ea4c297"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac787db9fd103d0ee5a067eab5ea4c297">merge_sorted_runs</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:ac787db9fd103d0ee5a067eab5ea4c297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11318a6a2eff8824102c0b19f8fc45e6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a11318a6a2eff8824102c0b19f8fc45e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a11318a6a2eff8824102c0b19f8fc45e6">merge_sorted_runs</a> (const std::string &amp;dirname, const std::vector&lt; std::string &gt; &amp;filenames, int first_run, int last_run, int new_run)</td></tr>
<tr class="separator:a11318a6a2eff8824102c0b19f8fc45e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116868c787944a97ce8b3baecd5faf0a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a116868c787944a97ce8b3baecd5faf0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a116868c787944a97ce8b3baecd5faf0a">merge_sorted_runs_with_id</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:a116868c787944a97ce8b3baecd5faf0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5675bb7b60440658a3b8c793d9c62feb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5675bb7b60440658a3b8c793d9c62feb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a5675bb7b60440658a3b8c793d9c62feb">merge_sorted_runs_with_id</a> (const std::string &amp;dirname, const std::vector&lt; std::string &gt; &amp;filenames, int first_run, int last_run, int new_run)</td></tr>
<tr class="separator:a5675bb7b60440658a3b8c793d9c62feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c4eaa88f4bb8b1623a4ba61cf42466"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51c4eaa88f4bb8b1623a4ba61cf42466"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a51c4eaa88f4bb8b1623a4ba61cf42466">merge_sorted_runs_with_2_ids</a> (const std::string &amp;dirname)</td></tr>
<tr class="separator:a51c4eaa88f4bb8b1623a4ba61cf42466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f19ca075c349e83ab304b9cb8e151a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a59f19ca075c349e83ab304b9cb8e151a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a59f19ca075c349e83ab304b9cb8e151a">merge_sorted_runs_with_2_ids</a> (const std::string &amp;dirname, const std::vector&lt; std::string &gt; &amp;filenames, int first_run, int last_run, int new_run)</td></tr>
<tr class="separator:a59f19ca075c349e83ab304b9cb8e151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b2353cf5aec5a939d38f8dfdc67e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac4b2353cf5aec5a939d38f8dfdc67e81">sort_run</a> ()</td></tr>
<tr class="separator:ac4b2353cf5aec5a939d38f8dfdc67e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6adec496fd26d381c0ee81ddacbdf7b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a6adec496fd26d381c0ee81ddacbdf7b2">sort_run_with_id</a> ()</td></tr>
<tr class="separator:a6adec496fd26d381c0ee81ddacbdf7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c96c4aea6d7937be06009108953bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a43c96c4aea6d7937be06009108953bea">sort_run_with_2_ids</a> ()</td></tr>
<tr class="separator:a43c96c4aea6d7937be06009108953bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2398a610e0359dbd995f747072367d1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2398a610e0359dbd995f747072367d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ae2398a610e0359dbd995f747072367d1">update_tile_info</a> (const T *coords, int64_t tile_id, const std::vector&lt; size_t &gt; &amp;attr_sizes)</td></tr>
<tr class="separator:ae2398a610e0359dbd995f747072367d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502db36ab414eb742822cbc6972b05d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a1502db36ab414eb742822cbc6972b05d">clear_book_keeping</a> ()</td></tr>
<tr class="separator:a1502db36ab414eb742822cbc6972b05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58cb5196a951755afaa8964e894f8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ae58cb5196a951755afaa8964e894f8bb">commit_book_keeping</a> ()</td></tr>
<tr class="separator:ae58cb5196a951755afaa8964e894f8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f72c601af3f26489dc945abf62832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a06f72c601af3f26489dc945abf62832f">commit_bounding_coordinates</a> ()</td></tr>
<tr class="separator:a06f72c601af3f26489dc945abf62832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3601b676d7a8bdee00dc089b2c210195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a3601b676d7a8bdee00dc089b2c210195">commit_mbrs</a> ()</td></tr>
<tr class="separator:a3601b676d7a8bdee00dc089b2c210195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8391ed5608a1300befcadf493c4503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ace8391ed5608a1300befcadf493c4503">commit_offsets</a> ()</td></tr>
<tr class="separator:ace8391ed5608a1300befcadf493c4503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ed0ae2704d8cccaddbe2c75f29a7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#af3ed0ae2704d8cccaddbe2c75f29a7b4">commit_tile_ids</a> ()</td></tr>
<tr class="separator:af3ed0ae2704d8cccaddbe2c75f29a7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6912a9f6c11de071dc85aa1878d6109a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a6912a9f6c11de071dc85aa1878d6109a">init_book_keeping</a> ()</td></tr>
<tr class="separator:a6912a9f6c11de071dc85aa1878d6109a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fecfcbcf3510605f3b9c4c146d20d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a70fecfcbcf3510605f3b9c4c146d20d5">load_book_keeping</a> ()</td></tr>
<tr class="separator:a70fecfcbcf3510605f3b9c4c146d20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec98f5ad85aa895f9cd49466167781f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#adec98f5ad85aa895f9cd49466167781f">load_bounding_coordinates</a> ()</td></tr>
<tr class="separator:adec98f5ad85aa895f9cd49466167781f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ed9573237a41f9655cbe9cef7fa43b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a38ed9573237a41f9655cbe9cef7fa43b">load_mbrs</a> ()</td></tr>
<tr class="separator:a38ed9573237a41f9655cbe9cef7fa43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee474eb7d99f987f9a95eee18cab102a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#aee474eb7d99f987f9a95eee18cab102a">load_offsets</a> ()</td></tr>
<tr class="separator:aee474eb7d99f987f9a95eee18cab102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24df11256353a40423604ede29f5a1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#af24df11256353a40423604ede29f5a1b">load_tile_ids</a> ()</td></tr>
<tr class="separator:af24df11256353a40423604ede29f5a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac4094cdea97450d1fe7e6c069aee4848"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac4094cdea97450d1fe7e6c069aee4848">array_schema_</a></td></tr>
<tr class="separator:ac4094cdea97450d1fe7e6c069aee4848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42edffdedb68f6d9387b630e614a1a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStorageManager_1_1BookKeeping.html">BookKeeping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a42edffdedb68f6d9387b630e614a1a2b">book_keeping_</a></td></tr>
<tr class="separator:a42edffdedb68f6d9387b630e614a1a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d528ff02e38fd5c504103e743e9d394"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a4d528ff02e38fd5c504103e743e9d394">fragment_name_</a></td></tr>
<tr class="separator:a4d528ff02e38fd5c504103e743e9d394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920650a1ba1e6923b387970d0b0919c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStorageManager_1_1ReadState.html">ReadState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a920650a1ba1e6923b387970d0b0919c9">read_state_</a></td></tr>
<tr class="separator:a920650a1ba1e6923b387970d0b0919c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac821268597048ee85e3b0f9a7ed134f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac821268597048ee85e3b0f9a7ed134f2">segment_size_</a></td></tr>
<tr class="separator:ac821268597048ee85e3b0f9a7ed134f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8440e27a50f5a2d05dcf227a92aa5ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ac8440e27a50f5a2d05dcf227a92aa5ce">temp_dirname_</a></td></tr>
<tr class="separator:ac8440e27a50f5a2d05dcf227a92aa5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bba52e89247da9f220083a40625cc85"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a2bba52e89247da9f220083a40625cc85">workspace_</a></td></tr>
<tr class="separator:a2bba52e89247da9f220083a40625cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575fde194ea2e0f1eaff4c939da801ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structStorageManager_1_1WriteState.html">WriteState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#a575fde194ea2e0f1eaff4c939da801ff">write_state_</a></td></tr>
<tr class="separator:a575fde194ea2e0f1eaff4c939da801ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91602363a194e997a36ba34a709431c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageManager_1_1Fragment.html#ae91602363a194e997a36ba34a709431c">write_state_max_size_</a></td></tr>
<tr class="separator:ae91602363a194e997a36ba34a709431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aab928c97ba2ed82b71fb011b1c4fef74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab928c97ba2ed82b71fb011b1c4fef74"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>StorageManager</b></td></tr>
<tr class="separator:aab928c97ba2ed82b71fb011b1c4fef74"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains information about a fragment. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a48e2456338d3271c094815d3e11f43b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageManager::Fragment::Fragment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>workspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>write_state_max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArraySchema.html">ArraySchema</a> *&#160;</td>
          <td class="paramname"><em>array_schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fragment_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="ac47c68b3770e0334954620557f021769"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageManager::Fragment::~Fragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3d6d9eb7854658f88dbc09f5455433d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::append_attribute_to_segment </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>attr_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends an attribute value to the corresponding segment, and returns (by reference) the (potentially variable) attribute value size. </p>

</div>
</div>
<a class="anchor" id="af50b4d47ac08eca95adb05e010290874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::append_coordinates_to_segment </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends the coordinate to the corresponding segment. </p>

</div>
</div>
<a class="anchor" id="a1d213b136596a6b756b7cd27e3f1b5de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArraySchema.html">ArraySchema</a>* StorageManager::Fragment::array_schema </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the array schema. </p>

</div>
</div>
<a class="anchor" id="a70af51da34a52acc74c8234f292746f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Fragment_1_1const__tile__iterator.html">const_tile_iterator</a> StorageManager::Fragment::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin tile iterator. </p>

</div>
</div>
<a class="anchor" id="a1502db36ab414eb742822cbc6972b05d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::clear_book_keeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the book keeping structures from main memory. </p>

</div>
</div>
<a class="anchor" id="ab06065659ce3af9a4f1929df73079065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::clear_read_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the read state. </p>

</div>
</div>
<a class="anchor" id="a87fe4b3e77c03a9665265f0e2a8468b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::clear_write_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the write state. </p>

</div>
</div>
<a class="anchor" id="ae58cb5196a951755afaa8964e894f8bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::commit_book_keeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the book keeping structures on the disk, but does not clear them from main memory. </p>

</div>
</div>
<a class="anchor" id="a06f72c601af3f26489dc945abf62832f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::commit_bounding_coordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the bounding coordinates on the disk, but does not clear them from main memory. </p>

</div>
</div>
<a class="anchor" id="a3601b676d7a8bdee00dc089b2c210195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::commit_mbrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the MBRs on the disk, but does not clear them from main memory. </p>

</div>
</div>
<a class="anchor" id="ace8391ed5608a1300befcadf493c4503"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::commit_offsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the offsets on the disk, but does not clear them from main memory. </p>

</div>
</div>
<a class="anchor" id="af3ed0ae2704d8cccaddbe2c75f29a7b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::commit_tile_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the tile ids on the disk, but does not clear them from main memory. </p>

</div>
</div>
<a class="anchor" id="aae64ed0524836f04f8dcb4b5d8b209e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::delete_tiles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the tiles of an attribute from main memory. </p>

</div>
</div>
<a class="anchor" id="a1c6054177999ae03f64c403a98bcffb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::finalize_last_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts and writes the last run on the disk. </p>

</div>
</div>
<a class="anchor" id="a1a5a6c47e126e446c1360cd56200f6c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_segment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes a segment to its corresponding file. </p>

</div>
</div>
<a class="anchor" id="af24534aab0c30c3ad4e698f7b3616551"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_segments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes all segments to their corresponding files. </p>

</div>
</div>
<a class="anchor" id="a041d59f0dbb25439d2d815fcb1ce5f8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_sorted_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes a sorted run on the disk. </p>

</div>
</div>
<a class="anchor" id="afc7113f64fcab841248023faa67006b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_sorted_run_with_2_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes a sorted run on the disk. </p>

</div>
</div>
<a class="anchor" id="a71370dc250d104ac47923ef9cbafb9e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_sorted_run_with_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes a sorted run on the disk. </p>

</div>
</div>
<a class="anchor" id="aa59edd2ba1f571d176f3bd3edfaa25aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_tile_info_to_book_keeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes the info about the lastly populated tile to the book keeping structures. </p>

</div>
</div>
<a class="anchor" id="af6174b7f9a3563b75171604ec699d365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::flush_write_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Flushes the write state onto the disk. </p>

</div>
</div>
<a class="anchor" id="ac0d3522c8b7572b4d378843486e9a81c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; StorageManager::Fragment::fragment_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the fragment name. </p>

</div>
</div>
<a class="anchor" id="a87ccd449a820cea6b30629ced081e597"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* StorageManager::Fragment::get_next_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1SortedRun.html">SortedRun</a> **&#160;</td>
          <td class="paramname"><em>runs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>runs_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the next cell from the input runs that precedes in the global cell order indicated by the input array schema. If the cell is variable-sized, the function will return into cell_size (passed by reference) the cell size. </p>

</div>
</div>
<a class="anchor" id="a56b3756bb279e40a64e10813714ea254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* StorageManager::Fragment::get_next_cell_with_2_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1SortedRun.html">SortedRun</a> **&#160;</td>
          <td class="paramname"><em>runs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>runs_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the next cell from the input runs that precedes in the global cell order indicated by the input array schema. </p>

</div>
</div>
<a class="anchor" id="afa066f5d08c4d147fd1061315aabc2be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* StorageManager::Fragment::get_next_cell_with_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classStorageManager_1_1SortedRun.html">SortedRun</a> **&#160;</td>
          <td class="paramname"><em>runs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>runs_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the next cell from the input runs that precedes in the global cell order indicated by the input array schema. </p>

</div>
</div>
<a class="anchor" id="a8a75d16440c30799c494260aaae21986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTile.html">Tile</a>* StorageManager::Fragment::get_tile_by_pos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a tile for a given attribute and tile position. </p>

</div>
</div>
<a class="anchor" id="a6912a9f6c11de071dc85aa1878d6109a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::init_book_keeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the book-keeping structures. </p>

</div>
</div>
<a class="anchor" id="ab0da2ac08f8dfbc96b293e58cbff0ef8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::init_read_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the read state. </p>

</div>
</div>
<a class="anchor" id="a73d50f4c7196b31fb28b1b2ce3647660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::init_write_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the write state. </p>

</div>
</div>
<a class="anchor" id="a70fecfcbcf3510605f3b9c4c146d20d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_book_keeping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the book-keeping structures. </p>

</div>
</div>
<a class="anchor" id="adec98f5ad85aa895f9cd49466167781f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_bounding_coordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the bounding coordinates. </p>

</div>
</div>
<a class="anchor" id="a38ed9573237a41f9655cbe9cef7fa43b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_mbrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the tile MBRs. </p>

</div>
</div>
<a class="anchor" id="aee474eb7d99f987f9a95eee18cab102a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_offsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the tile offsets. </p>

</div>
</div>
<a class="anchor" id="a1ba7c45a9ffbb5989b96d10cf6dc256d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;size_t, int64_t&gt; StorageManager::Fragment::load_payloads_into_segment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the payloads of the tiles of a given attribute from disk and into the corresponding segment in the read state, starting from the tile at position pos. Returns the segment utilization after the load, and the number of tiles loaded. </p>

</div>
</div>
<a class="anchor" id="ae64075a2c6dfd3b3c9c397dd418e3a9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_sorted_bin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads data into the fragment, which are stored in files inside the input directory. Each file stores the cells in binary form, sorted based on the global cell order specified in the array schema. Each cell must have the same binary format as that used when creating sorted runs triggered by <a class="el" href="classStorageManager.html#a30ed99b2cf15d3502ebfbec3d6dd9a37">StorageManager::write_cell</a>. </p>

</div>
</div>
<a class="anchor" id="af24df11256353a40423604ede29f5a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_tile_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the tile ids. </p>

</div>
</div>
<a class="anchor" id="a1de2c4f4eedc861cd970923c06d82b58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_tiles_from_disk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads tiles of a given attribute from disk, starting from the tile at position pos. </p>

</div>
</div>
<a class="anchor" id="a99159a6ae39e50637e6d3568ff9be9e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::load_tiles_from_segment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>segment_utilization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>tiles_in_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the tiles of an attribute from the corresponding segment and stores them into the read state. </p>

</div>
</div>
<a class="anchor" id="a157d23b2daea63bca4d6b04887392982"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::make_tiles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes tiles from existing sorted runs, stored in dirname. </p>

</div>
</div>
<a class="anchor" id="abb664e2edf5cf432db548093396d2bd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::make_tiles </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes tiles from existing sorted runs, stored in dirname. </p>

</div>
</div>
<a class="anchor" id="a9c16b86455f3dbb6d2fcd226ea726523"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::make_tiles_with_2_ids </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes tiles from existing sorted runs, stored in dirname. </p>

</div>
</div>
<a class="anchor" id="a2ccdfdf74d69ca5a99f252b9fdd0b351"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::make_tiles_with_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes tiles from existing sorted runs, stored in dirname. </p>

</div>
</div>
<a class="anchor" id="a787d513d7fd01c024cb7a8c3fad21ff5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::Fragment::merge_sorted_runs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges existing sorted runs. The dirname is the directory where the initial sorted runs are stored. </p>

</div>
</div>
<a class="anchor" id="ac787db9fd103d0ee5a067eab5ea4c297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::Fragment::merge_sorted_runs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges existing sorted runs. The dirname is the directory where the initial sorted runs are stored. </p>

</div>
</div>
<a class="anchor" id="a11318a6a2eff8824102c0b19f8fc45e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::merge_sorted_runs </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_run</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each run is named after an integer identifier. This function merges runs [first_run, last_run] into a new run called new_run in the next merge operation. </p>

</div>
</div>
<a class="anchor" id="a51c4eaa88f4bb8b1623a4ba61cf42466"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::Fragment::merge_sorted_runs_with_2_ids </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges existing sorted runs. The dirname is the directory where the initial sorted runs are stored. </p>

</div>
</div>
<a class="anchor" id="a59f19ca075c349e83ab304b9cb8e151a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::merge_sorted_runs_with_2_ids </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_run</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each run is named after an integer identifier. This function merges runs [first_run, last_run] into a new run called new_run in the next merge operation. </p>

</div>
</div>
<a class="anchor" id="a116868c787944a97ce8b3baecd5faf0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StorageManager::Fragment::merge_sorted_runs_with_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merges existing sorted runs. The dirname is the directory where the initial sorted runs are stored. </p>

</div>
</div>
<a class="anchor" id="a5675bb7b60440658a3b8c793d9c62feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::merge_sorted_runs_with_id </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>last_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_run</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each run is named after an integer identifier. This function merges runs [first_run, last_run] into a new run called new_run in the next merge operation. </p>

</div>
</div>
<a class="anchor" id="a67e10e1748161a55d0c75b0b19a58dd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override the delete operator so that only a <a class="el" href="classStorageManager.html">StorageManager</a> object can delete dynamically created <a class="el" href="classStorageManager_1_1Fragment.html">Fragment</a> objects. </p>

</div>
</div>
<a class="anchor" id="a65f0de60e42ac71a1b12be222c497f1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override the delete[] operator so that only a <a class="el" href="classStorageManager.html">StorageManager</a> object can delete dynamically created <a class="el" href="classStorageManager_1_1Fragment.html">Fragment</a> objects. </p>

</div>
</div>
<a class="anchor" id="ad5a5d0fa8938b7ee9f8ce15dadccfc2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStorageManager_1_1Fragment_1_1const__reverse__tile__iterator.html">const_reverse_tile_iterator</a> StorageManager::Fragment::rbegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begin reverse tile iterator. </p>

</div>
</div>
<a class="anchor" id="a366b8644d06b35c575847e9e681a42eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTile.html">Tile</a>* StorageManager::Fragment::rget_tile_by_pos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a tile for a given attribute and tile position, when traversing tiles in reverse order. This is important so that the segments are retrieved from the disk such that the tile that triggeres the segment retrieval appears in the end of the segment, rather than in the beginning. </p>

</div>
</div>
<a class="anchor" id="ac4b2353cf5aec5a939d38f8dfdc67e81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::sort_run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts a run in main memory. </p>

</div>
</div>
<a class="anchor" id="a43c96c4aea6d7937be06009108953bea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::sort_run_with_2_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts a run in main memory. </p>

</div>
</div>
<a class="anchor" id="a6adec496fd26d381c0ee81ddacbdf7b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::sort_run_with_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts a run in main memory. </p>

</div>
</div>
<a class="anchor" id="a77980a66c33881ac0d46ac5747dd759e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t StorageManager::Fragment::tile_num </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of tiles in the fragment. </p>

</div>
</div>
<a class="anchor" id="a56a88e321a7bfab562796e5ce239cee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t StorageManager::Fragment::tile_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the tile for the input attribute at the input position. </p>

</div>
</div>
<a class="anchor" id="ae2398a610e0359dbd995f747072367d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::update_tile_info </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>tile_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>attr_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the info of the currently populated tile with the input coordinates, tile id, and sizes of all attribute values in the cell. </p>

</div>
</div>
<a class="anchor" id="a00c43fd9d6fde012a35fe00e1ea569c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::write_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structStorageManager_1_1Cell.html">StorageManager::Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell into the fragment. </p>

</div>
</div>
<a class="anchor" id="a315b1953363fe48f7d488251d3467b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::write_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structStorageManager_1_1CellWithId.html">StorageManager::CellWithId</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell into the fragment. </p>

</div>
</div>
<a class="anchor" id="a05c91628918a91a39e16e661097f8b27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::write_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structStorageManager_1_1CellWith2Ids.html">StorageManager::CellWith2Ids</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cell_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell into the fragment. </p>

</div>
</div>
<a class="anchor" id="a93c4e22eeeadac8fc485852c4b7cba8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::write_cell_sorted </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell into the fragment, respecting the global cell order. The input cell carries no ids. </p>

</div>
</div>
<a class="anchor" id="aa5fd646ac3d5a604a2bcdcdf6b1f79c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::write_cell_sorted_with_2_ids </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell into the fragment, respecting the global cell order. The input cell carries a tile and a cell id. </p>

</div>
</div>
<a class="anchor" id="ae8ccba2bf546801841600dfbec98fe93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void StorageManager::Fragment::write_cell_sorted_with_id </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a cell into the fragment, respecting the global cell order. The input cell carries a single (tile) id. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac4094cdea97450d1fe7e6c069aee4848"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classArraySchema.html">ArraySchema</a>* StorageManager::Fragment::array_schema_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array schema (see <a class="el" href="classArraySchema.html">ArraySchema</a>). </p>

</div>
</div>
<a class="anchor" id="a42edffdedb68f6d9387b630e614a1a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStorageManager_1_1BookKeeping.html">BookKeeping</a> StorageManager::Fragment::book_keeping_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The book-keeping structures. </p>

</div>
</div>
<a class="anchor" id="a4d528ff02e38fd5c504103e743e9d394"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string StorageManager::Fragment::fragment_name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The fragment name. </p>

</div>
</div>
<a class="anchor" id="a920650a1ba1e6923b387970d0b0919c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStorageManager_1_1ReadState.html">ReadState</a>* StorageManager::Fragment::read_state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The read state. </p>

</div>
</div>
<a class="anchor" id="ac821268597048ee85e3b0f9a7ed134f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t StorageManager::Fragment::segment_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The segment size </p>

</div>
</div>
<a class="anchor" id="ac8440e27a50f5a2d05dcf227a92aa5ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string StorageManager::Fragment::temp_dirname_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporary directory. </p>

</div>
</div>
<a class="anchor" id="a2bba52e89247da9f220083a40625cc85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string StorageManager::Fragment::workspace_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The workspace where the array data are created. </p>

</div>
</div>
<a class="anchor" id="a575fde194ea2e0f1eaff4c939da801ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structStorageManager_1_1WriteState.html">WriteState</a>* StorageManager::Fragment::write_state_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The write state. </p>

</div>
</div>
<a class="anchor" id="ae91602363a194e997a36ba34a709431c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t StorageManager::Fragment::write_state_max_size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Max memory size of the write state when creating an array fragment. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>core/include/<a class="el" href="storage__manager_8h_source.html">storage_manager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 10 2015 15:04:03 for TileDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
