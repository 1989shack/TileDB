<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TileDB: core/include/capis/tiledb_queries.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TileDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f420c6cb9e0b983b642235f893ce5b8d.html">core</a></li><li class="navelem"><a class="el" href="dir_b44a0b93b302800d199942ab3e09513a.html">include</a></li><li class="navelem"><a class="el" href="dir_a1ad6d3fe80907961dd058d9544a0693.html">capis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tiledb_queries.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="tiledb__context_8h_source.html">tiledb_context.h</a>&quot;</code><br />
</div>
<p><a href="tiledb__queries_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6645800136da7c6f9885f16089ddfbd4"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#a6645800136da7c6f9885f16089ddfbd4">tiledb_clear_array</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name)</td></tr>
<tr class="separator:a6645800136da7c6f9885f16089ddfbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3a8940ab3800a55143bc7baeac2375"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#afe3a8940ab3800a55143bc7baeac2375">tiledb_define_array</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_schema_csv)</td></tr>
<tr class="separator:afe3a8940ab3800a55143bc7baeac2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f3ed9719ce68b4cbf73e4846e2eb04"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#a51f3ed9719ce68b4cbf73e4846e2eb04">tiledb_delete_array</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name)</td></tr>
<tr class="separator:a51f3ed9719ce68b4cbf73e4846e2eb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1589d4b0171cdafcf526ebd80f8f56"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#acc1589d4b0171cdafcf526ebd80f8f56">tiledb_export_csv</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name, const char *filename, const char **dim_names, int dim_names_num, const char **attribute_names, int attribute_names_num, bool reverse)</td></tr>
<tr class="separator:acc1589d4b0171cdafcf526ebd80f8f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6187b5a647f53ed523c2bc855edbe"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#ad8b6187b5a647f53ed523c2bc855edbe">tiledb_generate_data</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name, const char *filename, const char *filetype, unsigned int seed, int64_t cell_num)</td></tr>
<tr class="separator:ad8b6187b5a647f53ed523c2bc855edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539a59c691a6daa85509cc7943b02758"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#a539a59c691a6daa85509cc7943b02758">tiledb_load_bin</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name, const char *path, bool sorted)</td></tr>
<tr class="separator:a539a59c691a6daa85509cc7943b02758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132443942c8731971c22599c6dc353a6"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name, const char *filename)</td></tr>
<tr class="separator:a132443942c8731971c22599c6dc353a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae1ff575618bf6a6cf1ef745c637b94"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#aeae1ff575618bf6a6cf1ef745c637b94">tiledb_show_array_schema</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name)</td></tr>
<tr class="separator:aeae1ff575618bf6a6cf1ef745c637b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f87da93da89fdea9e505d2f5d488ef6"><td class="memItemLeft" align="right" valign="top">TILEDB_EXPORT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tiledb__queries_8h.html#a4f87da93da89fdea9e505d2f5d488ef6">tiledb_subarray</a> (const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *tiledb_context, const char *array_name, const char *result_name, const double *range, int range_size, const char **attribute_names, int attribute_names_num)</td></tr>
<tr class="separator:a4f87da93da89fdea9e505d2f5d488ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Stavros Papadopoulos <a href="#" onclick="location.href='mai'+'lto:'+'sta'+'vr'+'osp'+'@c'+'sai'+'l.'+'mit'+'.e'+'du'; return false;">stavr<span style="display: none;">.nosp@m.</span>osp@<span style="display: none;">.nosp@m.</span>csail<span style="display: none;">.nosp@m.</span>.mit<span style="display: none;">.nosp@m.</span>.edu</a></dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p>The MIT License</p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2014 Stavros Papadopoulos <a href="#" onclick="location.href='mai'+'lto:'+'sta'+'vr'+'osp'+'@c'+'sai'+'l.'+'mit'+'.e'+'du'; return false;">stavr<span style="display: none;">.nosp@m.</span>osp@<span style="display: none;">.nosp@m.</span>csail<span style="display: none;">.nosp@m.</span>.mit<span style="display: none;">.nosp@m.</span>.edu</a></dd></dl>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p>This file declares the C APIs for the TileDB queries. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6645800136da7c6f9885f16089ddfbd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_clear_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all data from an array. However, the array remains defined, i.e., one can still invoke <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv()</a> for this array, without having to redefine the array schema. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array whose data will be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#a51f3ed9719ce68b4cbf73e4846e2eb04">tiledb_delete_array</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afe3a8940ab3800a55143bc7baeac2375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_define_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_schema_csv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines an array, specifying its schema. Every array must be defined prior to its use. On error, it prints appopriate messages on stderr and returns an error code (outlined below). Each array is comprised of a set of <b>dimensions</b>, and a set of <b>attributes</b>. Each array <b>cell</b> is essentially a tuple, consisting of a set of dimension values, collectively called as <em>coordinates</em>, and a set of attribute values. The coordinates and attribute values may be of different <b>types</b>. All coordinates though must have the same type. The coordinates draw their values from their corresponding <b>dimension domains</b>. A cell may have <em>multiple</em> (fixed or variable) values on each attribute. TileDB stores internally only the <em>non-empty</em> (i.e., non-null, non-zero) cells.</p>
<p>An array is internally represented as a set of <b>fragments</b> (i.e., snapshots of the array after a set of updates), each consisting of a set of <b>tiles</b>. Each tile is essentially a <em>hyper-rectangle</em> in the <em>logical</em> (i.e., dimension) space that groups a set of non-empty cells. The tiles of an array may be <em>regular</em> or <em>irregular</em>. Regular tiles have <em>fixed</em> <b>tile extents</b> across each dimension, i.e., they have the same shape in the, logical space, but may have a different non-empty cell <b>capacity</b>. Irregular tiles have a <em>fixed</em> non-empty cell capacity, but may have different <em>shape</em> in the logical space.</p>
<p>Each array stores its cells internally in a <em>sorted</em> <b>tile order</b> and <b>cell order</b>. For the case of irregular tiles, the tile order is implied by the cell order.</p>
<p>Finally, TileDB updates arrays in <em>batches</em>, i.e., it modifies <em>sets of cells</em> instead of single cells. When a new set of cells is inserted into an array, TileDB initially creates a new array <b>fragment</b> encompassing only the updates. Periodically, as new updates arrive, TileDB <b>consolidates</b> multiple fragments into a single one. The consolidation frequency is defined by a <b>consolidation step</b> parameter. If this parameter is 1, every new fragment is always consolidated with the existing one. If it is larger than 1, then consolidation occurs in a <em>hierarchical</em> manner. For instance, if <b>s</b> is the consolidation step, each new fragment essentially represents a leaf of a complete <b>s</b>-ary tree that is constructed bottom-up. When <b>s</b> fragment-leaves are created, they are consolidated into a single one, which becomes their parent node in the tree, and the leaves are disregarded for the rest of they system lifetime. In general, whenever <b>s</b> fragment-nodes are created at the same level, they are consolidated into a new fragment that becomes their parent, and these nodes are disregarded thereafter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_schema_csv</td><td>The array schema, serialized in a CSV line string as follows (no spaces before and after the commas, this is a <em>single</em> CSV line): <hr/>
 <em>array_name</em> , <em>attribute_num</em> , <em>attribute_name<sub>1</sub></em> , ... , <em>attribute_name<sub>attribute_num</sub></em> , <em>dim_num</em> , <em>dim_name<sub>1</sub></em> , ... , <em>dim_name<sub>dim_num</sub></em> , <br />
<em>dim_domain_low<sub>1</sub></em>, <em>dim_domain_high<sub>1</sub></em>, ... , <em>dim_domain_low<sub>dim_num</sub></em>, <em>dim_domain_high<sub>dim_num</sub></em>, <br />
 <em>type<sub>attribute<sub>1</sub></sub></em> , ... , <em>type<sub>attribute<sub>attribute_num</sub></sub></em> , <em>type<sub>coordinates</sub></em> , <em>tile_extent<sub>1</sub></em>, ... , <em>tile_extent<sub>dim_num</sub></em> , <br />
<em>cell_order</em> , <em>tile_order</em> , <em>capacity</em> , <em>consolidation_step</em> <hr/>
 The details of each array schema item are as follows: <br />
<ul>
<li><b>array name</b> - <em>array_name</em> : <br />
 The name of the array whose schema is being defined. It can contain only alphanumerics and character '_'.</li>
<li><b>attribute names</b> - <em>attribute_num</em> , <em>attribute_name<sub>1</sub></em> , ... , <em>attribute_name<sub>attribute_num</sub></em> : <br />
 The names of the attributes of the array. Each name can contain only alphanumerics and character '_'. The number of given names must comply with the <em>attribute_num</em> value.</li>
<li><b>dimension names</b> - <em>dim_num</em> , <em>dim_name<sub>1</sub></em> , ... , <em>dim_name<sub>dim_num</sub></em> : <br />
 The names of the dimensions of the array. Each name can contain only alphanumerics and character '_'. The number of given names must comply with the <em>dim_num</em> value.</li>
<li><b>dimension domains</b> - <em>dim_domain_low<sub>1</sub></em>, <em>dim_domain_high<sub>1</sub></em>, ... , <em>dim_domain_low<sub>dim_num</sub></em>, <em>dim_domain_high<sub>dim_num</sub></em> <br />
 The domains of the dimensions. There should be a [low,high] pair for every dimension, whose order must follow that of the dimension names in the list <em>dim_name<sub>1</sub></em> , ... , <em>dim_name<sub>dim_num</sub></em>.</li>
<li><p class="startli"><b>types</b> - <em>type<sub>attribute<sub>1</sub></sub></em> , ... , <em>type<sub>attribute<sub>attribute_num</sub></sub></em> , <em>type<sub>coordinates</sub></em> <br />
 The types of the attributes and (collectively) of the coordinates. Specifically, if there are <em>attribute_num</em> attributes, there should be provided <em>attribute_num+1</em> types. The types of the attributes must be given first, following the order of the attribute names in the <em>attribute_name<sub>1</sub></em> , ... , <em>attribute_name<sub>attribute_num</sub></em> list. The type of the coordinates must be appear last. The supported attribute types are <b>char</b>, <b>int</b>, <b>int64</b>, <b>float</b>, and <b>double</b>. The supported coordinate types are <b>int</b>, <b>int64</b>, <b>float</b>, and <b>double</b>.</p>
<p class="startli">Optionally, one may specify the number of values to be stored for a particular attribute in each cell. This is done by appending ':' followed by the desired number of values after the type (e.g., <b>int:3</b>). If no such value is provided, the default is 1. If one needs to specify that an attribute may take a variable (unknown a priori) number of values, ':var' must be appended after the type (e.g., <b>int:var</b>). Note that the dimension type cannot have multiple values; a single set of coordinates uniquely identifies each cell.</p>
</li>
<li><b>tile extents</b> - <em>tile_extent<sub>1</sub></em>, ... , <em>tile_extent<sub>dim_num</sub></em> <br />
 It specifies the extent of a tile across each dimension. If this option is included, then the array will have <em>regular</em> tiles; if it is omitted, the array will have <em>irregular</em> tiles. If there are <em>dim_num</em> dimensions, there should be provided <em>dim_num</em> tile extents, following the same order as that of the dimension names in the <em>dim_name<sub>1</sub></em> , ... , <em>dim_name<sub>dim_num</sub></em> list. Each tile extent must be a non-negative real number that does not exceed the corresponding domain size.</li>
<li><b>cell order</b> - <em>cell_order</em> <br />
 The order in which the cells will be stored internally. The supported orders are <b>row-major</b>, <b>column-major</b> and <b>hilbert</b> (i.e., following the Hilbert space-filling curve). If no cell order is provided, the <em>default</em> is <b>row-major</b>.</li>
<li><b>tile order</b> - <em>tile_order</em> <br />
 The order in which the tiles will be stored internally. The supported orders are <b>row-major</b>, <b>column-major</b> and <b>hilbert</b> (i.e., following the Hilbert space-filling curve). If no cell order is provided, the default is <b>row-major</b>. This is applicable only to regular tiles.</li>
<li><b>capacity</b> - <em>capacity</em> <br />
 This specifies the fixed number of non-empty cells stored in each tile. It is applicable only to irregular tiles and, hence, cannot be used together with tile extents and tile order. If it is not provided, a default value is used.</li>
<li><b>consolidation step</b> - <em>consolidation_step</em> <br />
 It specifies the frequency of fragment consolidation, described above. If it is not provided, the default is 1.</li>
</ul>
<br />
 <b>NOTE:</b> To omit an optional array schema item (e.g., tile extents, capacity, etc), you <em>must</em> put character '*' in the corresponding field of the CSV string.<br />
 <br />
 <b>Examples</b><ul>
<li>my_array , 3 , attr1 , attr2 , attr3 , 2 , dim1 , dim2 , 0 , 100 , 0 , 200 , int:3 , double , char:var , int64 , * , hilbert , * , 1000 , 5 <br />
 This defines array <em>my_array</em>, which has <em>3</em> attributes and <em>2</em> dimensions. Dimension <em>dim1</em> has domain [0,100], <em>dim2</em> has domain [0,200]. The coordinates are of type <b>int64</b>. Attribute <em>attr1</em> is of type <b>int</b>, and each cell always stores <em>3</em> values on this attribute. Attribute <em>attr2</em> is of type <b>double</b>, and each cell always stores <em>1</em> value on this attribute. Attribute <em>attr3</em> is of type <b>char</b>, and each cell stores a <em>variable</em> number of values on this attribute (i.e., it stores arbitrary character strings). The array has <em>irregular</em> tiles. The cell order is <b>hilbert</b>. Each tile accommodates exactly <em>1000</em> (non-empty) cells. Finally, the consolidation step is set to <em>5</em>.</li>
<li>my_array , 3 , attr1 , attr2 , attr3 , 2 , dim1 , dim2 , 0 , 100 , 0 , 200 , int:3 , double , char:var , int64 , 10, 20 , hilbert , row-major , * , 5 <br />
 This is similar to the previous example, but now the array has <em>regular</em> tiles. In detail, it defines array <em>my_array</em>, which has <em>3</em> attributes and <em>2</em> dimensions. Dimension <em>dim1</em> has domain [0,100], <em>dim2</em> has domain [0,200]. The coordinates are of type <b>int64</b>. Attribute <em>attr1</em> is of type <b>int</b>, and each cell always stores <em>3</em> values on this attribute. Attribute <em>attr2</em> is of type <b>double</b>, and each cell always stores <em>1</em> value on this attribute. Attribute <em>attr3</em> is of type <b>char</b>, and each cell stores a <em>variable</em> number of values on this attribute (i.e., it stores arbitrary character strings). The array has <em>regular</em> tiles. Each tile has (logical) size <em>10x20</em>. The tile order is <b>row-major</b>, whereas the cell order is <b>hilbert</b>. Finally, the consolidation step is set to <em>5</em>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_PRARRSCHEMA</b><br />
 Failed to parse array schema </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#aeae1ff575618bf6a6cf1ef745c637b94">tiledb_show_array_schema</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51f3ed9719ce68b4cbf73e4846e2eb04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_delete_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all data from an array. Contrary to <a class="el" href="tiledb__queries_8h.html#a6645800136da7c6f9885f16089ddfbd4">tiledb_clear_array()</a>, the array does <b>not</b> remain defined, i.e., one must redefine its schema (via <a class="el" href="tiledb__queries_8h.html#afe3a8940ab3800a55143bc7baeac2375">tiledb_define_array()</a>) prior to loading data to it (e.g., via <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv()</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array that will be deleted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#a51f3ed9719ce68b4cbf73e4846e2eb04">tiledb_delete_array</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc1589d4b0171cdafcf526ebd80f8f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_export_csv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>dim_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_names_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>attribute_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_names_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exports the (binary) data of an array into a CSV file. The documentation on the exported CSV format can be found in function <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv()</a>. On error, it prints a message on stderr and returns an error code (shown below).</p>
<p>The user may also specify a subset of attributes and dimensions from the array to export. Also, he/she may specify any order of attributes and dimensions, as well as multiplicities.</p>
<p>In case the user wishes to completely hide the dimensions or the attributes, he/she should include "__hide" as the only name in the dimension or attribute name list.</p>
<p>Finally, the user may specify whether the array cells should be exported in the stored order or in <em>reverse</em>.</p>
<p><b>Examples</b></p>
<p>Supposing that tiledb_context stores a pointer to a <a class="el" href="structTileDB__Context.html">TileDB_Context</a> object, and assuming that the array has dimensions <em>dim1</em>,<em>dim2</em> and attributes <em>attr1</em>,<em>attr2</em>,<em>attr3</em> :</p><ul>
<li>tiledb_export_csv(tiledb_context, "A", "A.csv", {}, 0, {}, 0, false) <br />
 Exports into "A.csv" all the cells of "A" in the order they are stored, including all the coordinates and attributes.</li>
<li>tiledb_export(tiledb_context, "A", "A.csv", {"dim1"}, 1, {"attr1","attr2"}, 2, false) <br />
 Exports into "A.csv" all the cells of "A" in the order they are stored, including only the coordinates on the <em>dim1</em> dimension and the values on the <em>attr1</em>,<em>attr2</em> attributes.</li>
<li>tiledb_export_csv(tiledb_context, "A", "A.csv", {"dim1"}, 1, {"attr1","attr2"}, 2, true) <br />
 Same as above, but the cells are exported in the reverse order.</li>
<li>tiledb_export_csv(tiledb_context, "A", "A.csv", {"__hide"}, 1, {attr1,attr2}, 2, false) <br />
 Same as the first example, but no coordinate is exported.</li>
<li>tiledb_export_csv(tiledb_context, "A", "A.csv", {"dim1"}, 1, {"__hide"}, 2, false) <br />
 Same as the first example, but no attribute value is exported.</li>
<li>tiledb_export_csv(tiledb_context, "A", "A.csv", {"dim1"}, 1, {"attr1","attr2","attr1"}, 2, false) <br />
 Same as the first example, but now the <em>attr1</em> values are shown twice (once before those of <em>attr2</em> and once after).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array whose data will be exported. </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the CSV file that will hold the output. </td></tr>
    <tr><td class="paramname">dim_names</td><td>An array holding the dimension names to be exported. If it is empty, then all the coordinates will be exported. If it contains special name "__hide", then no coordinates will be exported. </td></tr>
    <tr><td class="paramname">dim_names_num</td><td>The number of elements in dim_names </td></tr>
    <tr><td class="paramname">attribute_names</td><td>An array holding the attribute names to be exported. If it is empty, then all the attribute values will be exported. If it contains special name "__hide", then no attribute values will be exported. </td></tr>
    <tr><td class="paramname">attribute_names_num</td><td>The number of elements in attribute_names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed</li>
<li><b>TILEDB_EOARR</b><br />
 Failed to open array</li>
<li><b>TILEDB_ECARR</b><br />
 Failed to close array </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv</a>, <a class="el" href="tiledb__queries_8h.html#ad8b6187b5a647f53ed523c2bc855edbe">tiledb_generate_data</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8b6187b5a647f53ed523c2bc855edbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_generate_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filetype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>cell_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a synthetic dataset in either <b>CSV</b> or <b>binary</b> form, which is acceptable by a TileDB load command, namely <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv()</a> or <a class="el" href="tiledb__queries_8h.html#a539a59c691a6daa85509cc7943b02758">tiledb_load_bin()</a>, respectively. The dataset essentially consists of a collection of cells, whose format complies with the schema of an array given as input to the function. This means that the input array must already be defined. The number of cells to be generated, as well as the seed to the random generator, are given as inputs to the function as well.</p>
<p><b>Data distribution</b></p>
<ul>
<li><em>Cooridinates</em> <br />
 The coordinate values are drawn uniformly at random from their corresponding dimension domains defined in the array schema.</li>
<li><em>Attribute values</em> <br />
 The attribute values depend on their type. The real data values (i.e., <b>float</b> and <b>double</b>) are drawn uniformly at random from [0.0,1.0]. The <b>int</b> and <b>int64_t</b> data values are drawn uniformly at random from [0,max()], where max() is the maximum value of the corresponding type supported by the system that calls the function. Finally, the <b>char</b> values are drawn uniformly at random from ASCII domain [45,126], i.e., all the characters between and including '-' and '~'.</li>
</ul>
<p><b>CSV file format</b> <br />
This is described in detail in <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv()</a>. The difference is that the generated data do not contain null values and deletions.</p>
<p><b>Binary file format</b> <br />
This is described in detail in <a class="el" href="tiledb__queries_8h.html#a539a59c691a6daa85509cc7943b02758">tiledb_load_bin()</a>. The difference is that the generated data do not contain null values and deletions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array for which the data will be generated. </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the produced file. </td></tr>
    <tr><td class="paramname">filetype</td><td>The type of the generated file. It can be either <b>csv</b> (CSV file) or <b>bin</b> (binary file). </td></tr>
    <tr><td class="paramname">seed</td><td>The seed that will be used internally for the random generator. </td></tr>
    <tr><td class="paramname">cell_num</td><td>The number of cells to be generated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed</li>
<li><b>TILEDB_EIARG</b><br />
 Invalid argument </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv</a>, <a class="el" href="tiledb__queries_8h.html#a539a59c691a6daa85509cc7943b02758">tiledb_load_bin</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a539a59c691a6daa85509cc7943b02758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_load_bin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a collection of binary files into an array. The user specifies the path to a single binary file name, or to a directory containing a collection of binary files (all of which will be loaded into the array). Moreover, the user may indicate whether the cells in each file are sorted along the cell order defined in the array schema or not. This has a dramatic effect on performance; if the cells are already sorted, then the costly sorting operation upon loading is avoided and, hence, the load performance is substantially improved. Note that, for the case of multiple sorted files, loading is essentially a <em>merge</em> operation (the cells are sorted in each file, but not necessarily across files). On error, it prints a message on stderr and returns an error code (see below).</p>
<p><b>Binary file format</b> <br />
 Each binary file is essentially a collection of cells in binary form, concatenated one after the other in the file. The general format of each binary cell is the following (all values in binary format and of the corresponding type defined in the array schema, and '|' denotes binary concatenation):</p>
<hr/>
<p> <em>c<sub>1</sub></em> | ... | <em>c<sub>dim_num</sub></em> | <em>a<sub>1</sub></em> | ... | <em>a<sub>attribute_num</sub></em> </p><hr/>
<p>where <em>c<sub>1</sub></em> , ... , <em>c<sub>dim_num</sub></em> are the <em>dim_num</em> coordinates and <em>a<sub>1</sub></em> , ... , <em>a<sub>attribute_num</sub></em> are the <em>attribute_num</em> attributes.</p>
<p>If an attribute takes multiple values, but their number is <em>predefined</em> in the array schema (e.g., <b>int:3</b>), then these values are simply concatenated next to each other. However, if the number of values is <em>variable</em> (e.g, <b>int:var</b>), then the number of values must precede the actual attribute values, and it should be of type <b>int</b>. For example, <b>3 | 0.1 | 0.2 | 0.3</b> for an attribute <em>attr1</em> whose type was defined as <b>float:var</b> means that this cell stores <b>3</b> values on attribute <em>attr1</em>, namely <b>0.1,0.2,0.3</b> (more examples are provided below). Moreover, if even a single attribute is variable-sized, the size of the <b>entire</b> binary cell must be included immediately after the coordinates and before the attributes, and it must be of type <b>size_t</b> (i.e., <b>unsigned int</b>). Note that the cell size is essentially the size of coordinates, plus the size of attributes, plus the size of a <b>size_t</b> that holds the size value (examples below).</p>
<p>A <b>null</b> attribute value is represented by the <b>maximum</b> value in the domain of the corresponding type. For attributes of type <b>char</b>, null is represented by character '*'.</p>
<p>A <b>deletion</b> of a cell in TileDB is represented by a cell that contains the coordinates of the cell to be deleted, and stores the <b>maximum-1</b> value of the corresponding type in <em>all</em> the attribute fields. For attributes of type <b>char</b>, a deletion is represented by character '$'.</p>
<p><b>Example binary cells</b> <br />
 Suppose that the array contains <b>2 dimensions</b> and <b>3 attributes</b>, whose types are defined as <b>int:3,double,char,int64</b> (recall that the last type corresponds always to all coordinates collectively). Observe that this schema essentially defines a <b>fixed size</b> for <em>all</em> cells in the array.</p><ul>
<li>1 | 3 | 10 | 11 | 12 | 0.1 | p <br />
 (1,3) are the coordinates of the cell (of type <b>int64</b>). (10,11,12) is the value on the <em>first</em> attribute (of type <b>int</b>). <b>0.1</b> is the value of the <em>second</em> attribute (of type <b>double</b>). Finally, <b>p</b> is the value of the <em>third</em> attribute (of type <b>char</b>).</li>
</ul>
<p>Now suppose that the array contains <b>2 dimensions</b> and <b>3 attributes</b> as in the previous example, but their types are now defined as <b>int:3,double:var,char:var,int64</b>. This means that the cells of the array may be of <b>variable size</b>. Also let an <b>int</b> value consume <em>4 bytes</em>, a <b>size_t</b> <em>4 bytes</em>, a <b>double</b> <em>8 bytes</em>, a <b>char</b> <em>1 byte</em>, and a <b>int64</b> <em>8 bytes</em>.</p><ul>
<li>1 | 3 | 60 | 10 | 11 | 12 | 2 | 0.1 | 0.2 | 4 | paok <br />
 (1,3) are the coordinates of the cell (of type <b>int64</b>). <b>60</b> is the size in bytes of the entire cell (including even this size value itself). (10,11,12) is the value on the <em>first</em> attribute (of type <b>int</b>). <b>2</b> is the number of values for the <em>second</em> attribute (of type <b>int</b>). (0.1,0.2) is the values of the <em>second</em> attribute (of type <b>double</b>). <b>4</b> is the number of characters in the string of the <em>third</em> attribute (of type <b>int</b>). Finally, <b>paok</b> is the string of the <em>third</em> attribute (of type <b>char</b>), and my favorite soccer team in Greece :P.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array into which the binary file(s) is loaded. Note that the array must already be defined. </td></tr>
    <tr><td class="paramname">path</td><td>The path to a binary file or to a directory of binary files. If it is a file, then this single file will be loaded. If it is a directory, <b>all</b> the files in the directory will be loaded. </td></tr>
    <tr><td class="paramname">sorted</td><td>Indicates whether the cells in the binary file(s) are sorted along the cell order defined in the array schema. This choice will have a great effect on performance (sorted cells are loaded substantially faster). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed</li>
<li><b>TILEDB_EOARR</b><br />
 Failed to open array</li>
<li><b>TILEDB_ECARR</b><br />
 Failed to close array </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#afe3a8940ab3800a55143bc7baeac2375">tiledb_define_array</a>, <a class="el" href="tiledb__queries_8h.html#acc1589d4b0171cdafcf526ebd80f8f56">tiledb_export_csv</a>, <a class="el" href="tiledb__queries_8h.html#a132443942c8731971c22599c6dc353a6">tiledb_load_csv</a>, <a class="el" href="tiledb__queries_8h.html#ad8b6187b5a647f53ed523c2bc855edbe">tiledb_generate_data</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a132443942c8731971c22599c6dc353a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_load_csv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a CSV file into an array. On error, it prints a message on stderr and returns an error code (shown below). The CSV file must have the following format.</p>
<p><b>CSV file format</b> <br />
 The CSV file is essentially a collection of (CSV) lines, where each line represents an array cell. The general format of each line is of the form (no spaces before and after each comma):</p>
<hr/>
<p> <em>c<sub>1</sub></em> , ... , <em>c<sub>dim_num</sub></em> , <em>a<sub>1</sub></em> , ... , <em>a<sub>attribute_num</sub></em> </p><hr/>
<p>where <em>c<sub>1</sub></em> , ... , <em>c<sub>dim_num</sub></em> are the <em>dim_num</em> coordinates and <em>a<sub>1</sub></em> , ... , <em>a<sub>attribute_num</sub></em> are the <em>attribute_num</em> attributes.</p>
<p>If an attribute takes multiple values, but their number is <em>predefined</em> in the array schema (e.g., <b>int:3</b>), then these values are simply included next to each other and separated by comma. However, if the number of values is <em>variable</em> (e.g, <b>int:var</b>), then the number of values must precede the actual attribute values (e.g., "3,0.1,0.2,0.3" for an attribute <em>attr1</em> whose type was defined as <b>float:var</b> means that this cell stores three values on attribute <em>attr1</em>, namely 0.1, 0.2, and 0.3 (more examples are provided below).</p>
<p>There is one exception of the above for the case of <em>strings</em> (i.e., variable lengthed attributes defined as <b>char:var</b>). These are simply given in one CSV field (e.g., "abc"), since their number can be easily deduced by the size of the string (the same is not true for numerics). If multiple strings are to be included in a <b>var:char</b> attribute, the user must simply include an arbitray separator. For instance, one may store strings "abc" and "defg" as "abc*defg". It falls upon the "conslumer" of the data to recognize how to split the strings (TileDB simply stores a variable number of characters). Finally, note that, if an attribute is defined, say, as <b>char:3</b> (i.e., the number of characters for this attribute per cell is known upon definition), then the line must simply include a,b,c instead of "abc" (i.e., it is treated as in the case of the other types).</p>
<p>A <b>null</b> attribute value is represented by character '*'.</p>
<p>A <b>deletion</b> of a cell in TileDB is represented by a CSV line that contains the coordinates of the cell to be deleted, and stores character '$' in <em>all</em> the attribute fields.</p>
<p><b>Example CSV lines</b> <br />
 Suppose that the array contains <b>2 dimensions</b> and <b>3 attributes</b>, whose types are defined as <b>int:2,double:var,char:var,int64</b> (recall that the last type corresponds always to all coordinates collectively).</p><ul>
<li>1,3,10,11,2,0.1,0.2,paok <br />
 (1,3) are the coordinates of the cell (of type int64). (10,11) is the value on the first attribute (of type int). (0.1,0.2) is the value of the second attribute (of type double). Finally, "paok" is the value of the third attribute (of type char), and my favorite soccer team in Greece :P.</li>
<li>1,3,10,11,*,paok <br />
 Same as above, but now the second attribute value is null.</li>
<li>1,3,$,$,$ <br />
 Cell (1,3) is being deleted.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array into which the CSV file is loaded. Note that the array must already be defined. </td></tr>
    <tr><td class="paramname">filename</td><td>The name of the CSV file to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed</li>
<li><b>TILEDB_EOARR</b><br />
 Failed to open array</li>
<li><b>TILEDB_ECARR</b><br />
 Failed to close array </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#afe3a8940ab3800a55143bc7baeac2375">tiledb_define_array</a>, <a class="el" href="tiledb__queries_8h.html#acc1589d4b0171cdafcf526ebd80f8f56">tiledb_export_csv</a>, <a class="el" href="tiledb__queries_8h.html#a539a59c691a6daa85509cc7943b02758">tiledb_load_bin</a>, <a class="el" href="tiledb__queries_8h.html#ad8b6187b5a647f53ed523c2bc855edbe">tiledb_generate_data</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeae1ff575618bf6a6cf1ef745c637b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_show_array_schema </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the schema of an array on the standard output. The array must be defined. On error, it prints a message on stderr and returns an error code (shown below). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array whose schema is printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#afe3a8940ab3800a55143bc7baeac2375">tiledb_define_array</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f87da93da89fdea9e505d2f5d488ef6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TILEDB_EXPORT int tiledb_subarray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTileDB__Context.html">TileDB_Context</a> *&#160;</td>
          <td class="paramname"><em>tiledb_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>array_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>result_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>range_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>attribute_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>attribute_names_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new array with the same schema as the input array (or including a subset of the attributes in a potentially different order), conataining only the cells that lie in the input range. The range must be a hyper-rectangle that is completely contained in the dimension space. It is also given as a sequence of [low,high] pairs across each dimension. On error, it prints a message on stderr and returns an error code (shown below).</p>
<p><b>Examples</b></p>
<p>Supposing that tiledb_context stores a pointer to a <a class="el" href="structTileDB__Context.html">TileDB_Context</a> object, and assuming that the array has dimensions <em>dim1</em>,<em>dim2</em> with domains [0,100] and [0,200], respectively, and attributes <em>attr1</em>,<em>attr2</em>,<em>attr3</em> :</p><ul>
<li>tiledb_subarray(tiledb_context, "A", "A_sub", {10,20,100,150}, 4, {}, 0) <br />
 Creates a new array "A_sub" with exactly the same schema as "A", but only containing the cells within rectangle [10,20] (<em>dim1</em>) , [100,150] (*dim2).</li>
<li>tiledb_subarray(tiledb_context, "A", "A_sub", {10,20,100,150}, 4, {"attr1","attr2"}, 2) <br />
 Same as the first example, but now "A_sub" contains only two attributes (<em>attr1</em>,<em>attr2</em>).</li>
<li>tiledb_subarray(tiledb_context, "A", "A_sub", {10,20,100,150}, 4, {"attr2","attr1"}, 2) <br />
 Same as the second example, but <em>attr1</em> and <em>attr2</em> appear in a different order in "A_sub".</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tiledb_context</td><td>The TileDB state consisting of the TileDB modules. </td></tr>
    <tr><td class="paramname">array_name</td><td>The name of the array the subarray will be applied on. </td></tr>
    <tr><td class="paramname">result_name</td><td>The name of the output array. </td></tr>
    <tr><td class="paramname">range</td><td>The range of the subarray. It must contain real values. </td></tr>
    <tr><td class="paramname">range_size</td><td>The nunber of elements of the range vector. It must be equal to 2*dim_num, where <em>dim_num</em> is the number of the dimensions of the array. </td></tr>
    <tr><td class="paramname">attribute_names</td><td>A vector holding the attribute names to be included in the schema of the result array. If it is empty, then all the attributes of the input array will appear in the output array. </td></tr>
    <tr><td class="paramname">attribute_names_num</td><td>The number of elements in attribute_names </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code, which can be one of the following:<ul>
<li><b>0</b><br />
 Success</li>
<li><b>TILEDB_ENDEFARR</b><br />
 Undefined array</li>
<li><b>TILEDB_EFILE</b><br />
 File operation failed</li>
<li><b>TILEDB_EOARR</b><br />
 Failed to open array</li>
<li><b>TILEDB_ECARR</b><br />
 Failed to close array </li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structTileDB__Context.html">TileDB_Context</a>, <a class="el" href="tiledb__queries_8h.html#afe3a8940ab3800a55143bc7baeac2375">tiledb_define_array</a>, <a class="el" href="tiledb__error_8h.html">tiledb_error.h</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 29 2015 17:52:58 for TileDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
