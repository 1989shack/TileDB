steps:

# Need this for virtualenv
- task: UsePythonVersion@0
  inputs:
    versionSpec: '3.8'

- bash: |
    set -e pipefail
    if [[ "$TILEDB_TESTS_ENABLE_ARROW" == "ON" ]]; then
      pip install pyarrow pybind11 numpy
    fi

- powershell: |
    #so, changes to git config come too late, because fetch has already been made by time we're here...
    #have to massage the files directly (if that even proves to be the solution...)
    #~ echo "about2: git --version"
    #~ git --version

    #~ echo "about2: (before) git config --list"
    #~ git config --list --show-origin
    #~ #Seem to be two (2) core.autocrlf lines displayed for plain 'git config --list', will they both change???
    #~ #(anything to do with the (two) include.path=... items?)
    #~ Set-PSDebug -Trace 1 
    #~ echo "about2: (before) git config core.autocrlf"
    #~ git config core.autocrlf
    #~ echo "about2: git config core.autocrlf false"
    #~ git config core.autocrlf false
    #~ echo "about2: (after) git config core.autocrlf"
    #~ git config core.autocrlf
    #~ Set-PSDebug -Trace 0 
    #~ echo "about2: (after) git config --list"
    #~ git config --list --show-origin

    #~ echo "about2: git config --global --list"
    #~ git config --global --list

    #~ echo "about2: (before) git config --system --list"
    #~ git config --system --list
    #~ git config --system core.autocrlf false
    #~ git config --system core.autocrlf
    #~ echo "about2: (after) git config --system --list"
    #~ git config --system --list

    #~ echo "about2: (before2) git config --list"
    #~ #see if it's now clear here after being clear in 'system' above...
    #~ git config --list  --show-origin
    
    #so, I suddenly realize the fetch has *already* occurred with those settings...
    #(altho, the clone I was doing, still seemed to have crlf line endings, but maybe that's how they are on patches already in 'dev' branch?)
    #but, we may be able to 'renormalize' somehow, though probably not with a git add, as shown...
    #... here https://docs.github.com/es/github-ae@latest/github/using-git/configuring-git-to-handle-line-endings

    Write-Host "Is npm present before we install?" #vm list suggests so
    c:\msys64\usr\bin\which npm
    Write-Host "netstat b4 azurite..."
    netstat -abo #'b' requires elevation, s'posed to have it
    
    $useTileDBInstallNodeJS = $True
    if($useTileDBInstallNodeJS) {
      & "$env:BUILD_SOURCESDIRECTORY\scripts\install-run-azurite.ps1"
      #The start of azurite in install-run-azurite.pas1 (above) with 'npx' is failing, 
      #see if the direct call withOUT npx, similar to one in 'else' branch will work...
      #(realizing that there could be artifacts from the attempt in the .ps1 causing conflicts also...)

      #$npxCmd = "start `"azurite host window`" " + $npxCmdPath + " azurite-blob" + " --silent --location " + $azuriteDataPath + " --debug " + $azuriteDebugLog + " --blobPort 10000 --blobHost 0.0.0.0 "
      #will this start in background, or does it need separate window???
      #azurite-blob --silent --location " + $azuriteDataPath + " --debug " + $azuriteDebugLog + " --blobPort 10000 --blobHost 127.0.0.1
      $azuriteDataPath = (Join-Path $env:TEMP "azuriteData")
      New-Item -ItemType Directory -Path $azuriteDataPath
      $azuriteDebugLog = (Join-Path $env:TEMP "azuriteDebugLog.Log")
      #azurite-blob --silent --location $azuriteDataPath --debug $azuriteDebugLog --blobPort 10000 --blobHost 127.0.0.1
      #seems likely were just waiting for job to time-out after azurite-blob started, try separate window...
      #TBD: could attempt to invoke 'azurite' be conflicting with something azurish already on node???
      cmd /c "start `"azurite`" azurite-blob --silent --location $azuriteDataPath --debug $azuriteDebugLog --blobPort 10000 --blobHost 127.0.0.1"
    }
    else { #using the node/npm already present in vm
      #alternate:
      npm install -g azurite
      #$npxCmd = "start `"azurite host window`" " + $npxCmdPath + " azurite-blob" + " --silent --location " + $azuriteDataPath + " --debug " + $azuriteDebugLog + " --blobPort 10000 --blobHost 0.0.0.0 "
      #will this start in background, or does it need separate window???
      #azurite-blob --silent --location " + $azuriteDataPath + " --debug " + $azuriteDebugLog + " --blobPort 10000 --blobHost 127.0.0.1
      $azuriteDataPath = (Join-Path $env:TEMP "azuriteData")
      New-Item -ItemType Directory -Path $azuriteDataPath
      $azuriteDebugLog = (Join-Path $env:TEMP "azuriteDebugLog.Log")
      #azurite-blob --silent --location $azuriteDataPath --debug $azuriteDebugLog --blobPort 10000 --blobHost 127.0.0.1
      #seems likely were just waiting for job to time-out after azurite-blob started, try separate window...
      #TBD: could attempt to invoke 'azurite' be conflicting with something azurish already on node???
      cmd /c "start `"azurite`" azurite-blob --silent --location $azuriteDataPath --debug $azuriteDebugLog --blobPort 10000 --blobHost 127.0.0.1"
    }

    #present list of tasks to see if 'node' is running
    echo "all tasks"
    tasklist
    echo "is 'node' present?"
    tasklist | findstr /i node.exe
    Write-Host "netstat -abo (after azurite)"
    netstat -abo #'b' requires elevation, s'posed to have it
    
    #colon's apparently a no-no... Write-Host "contents of $azuriteDebugLog:"
    Write-Host "contents of $azuriteDebugLog..."
    c:\msys64\usr\bin\cat $azuriteDebugLog

    #~ $host.SetShouldExit(-1)
    #~ return -1

    #docs say 'pre-installed', here's hoping they've invoked shell first time so we can just add to path and use...
    $env:Path += ";c:\msys64\usr\bin"
    #echo "about2: cat c:\ProgramData\Git\config"
    #cat c:\ProgramData\Git\config
    #so,apparently powershell has a 'cat' of its own...
    #echo "about2: which cat"
    #which cat
    #echo "about2: ls c:\ProgramData\Git\config"
    #ls c:\ProgramData\Git\config
    if(Test-Path "c:\ProgramData\Git\config"){
      c:\msys64\usr\bin\cat c:\ProgramData\Git\config
    }
    else {
      Write-Host "did not find c:\ProgramData\Git\config"
    }
    #git version 2.23+, location changed... think vm image says 2.29.x installed...#
    if(Test-Path "c:\Program Files\Git\etc\gitconfig"){
      c:\msys64\usr\bin\cat "c:\Program Files\Git\etc\gitconfig"
      cacls "c:\Program Files\Git\etc\gitconfig"
    }
    else {
      Write-Host "did not find c:\Program Files\Git\etc\gitconfig"
    }
    hexdump --version
    hexdump --help
    
    echo "about2: pip3 --version"
    pip3 --version #is pip3 already available along with python3?

    #should be windows version of git, we haven't installed one in msys2...
    #git clone -b dlh/explore-CI-buildissues http://github.com/TileDB-Inc/tiledb ./gh.tiledb.git
    #hmm, I suddenly recall, all of this be running in an already fetched commit from repository...
    
    #where are we, and what's there?
    echo "about2: dir"
    dir
    echo "what patches are here?"
    dir .\cmake\inputs\patches\ep_azuresdk
    
    function deleteCR([string] $path, [string]$file){
      write-host "path: $path"
      write-host "file: $file"
      $infile = Join-Path $path $file
      write-host "infile: $infile"
      #$outfile = Join-Path $path $file ".nocr"
      #$outfile = (Join-Path $path ($file + ".nocr") )
      $outname = $file + ".nocr"
      write-host "outname: $outname"
      $outfile = (Join-Path $path $outname )
      write-host "outfile: $outfile"
      #c:\msys64\usr\bin\tr -d < (Join-Path $path $file) > (JoinPath $path $file ".nocr")
      cmd /c "c:\msys64\usr\bin\tr -d '\r' < $infile > $outfile"
      #cmd /c 'c:\msys64\usr\bin\tr -d "\r" < $infile > $outfile'
      #cmd /c "c:\msys64\usr\bin\tr -d '\r' '<' $infile '>' $outfile"
      #think mingw rtl is trashing paths (the backslashes inter'd as escapes in string)...
      #bash -c "c:\msys64\usr\bin\tr -d '\r' < $infile > $outfile"
      if (Test-Path $outfile) {
        dir $path
        remove-item -path $infile #(Join-Path $path $file)
        ren $outfile $file #(Join-Path $path $file ".nocr") (Join-Path $path $file)
        dir $path
      }
    }
    
    echo "about2: hexdump ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-base64.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-base64.patch
    #tr -d '\r' ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-base64.patch
    Set-PSDebug -Trace 1 
    deleteCR "./cmake/inputs/patches/ep_azuresdk" "azure-storage-lite-base64.patch"
    Set-PSDebug -Trace 0
    echo "about2b: hexdump ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-base64.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-base64.patch

    echo "about2: hexdump ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-storage_url.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-storage_url.patch
    #tr -d '\r' ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-storage_url.patch
    deleteCR "./cmake/inputs/patches/ep_azuresdk" "azure-storage-lite-storage_url.patch"
    echo "about2b: hexdump ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-storage_url.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/azure-storage-lite-storage_url.patch

    echo "about2: hexdump ./cmake/inputs/patches/ep_azuresdk/remove-uuid-dep.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/remove-uuid-dep.patch
    #tr -d '\r' ./cmake/inputs/patches/ep_azuresdk/remove-uuid-dep.patch
    deleteCR "./cmake/inputs/patches/ep_azuresdk" "remove-uuid-dep.patch"
    echo "about2b: hexdump ./cmake/inputs/patches/ep_azuresdk/remove-uuid-dep.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/remove-uuid-dep.patch

    echo "about2: hexdump ./cmake/inputs/patches/ep_azuresdk/azurite-support.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/azurite-support.patch
    #tr -d '\r' ./cmake/inputs/patches/ep_azuresdk/azurite-support.patch
    deleteCR "./cmake/inputs/patches/ep_azuresdk" "azurite-support.patch"
    echo "about2b: hexdump ./cmake/inputs/patches/ep_azuresdk/azurite-support.patch"
    hexdump -C ./cmake/inputs/patches/ep_azuresdk/azurite-support.patch

    #Was YAML spec'd by a retired FortranIV programmer, or Grace Hopper of (pre-)cobol fame? (fixed indentation schemes)
    #doesn't even allow comments out-of-indentation level, even python is that generous...    
    #~ $host.SetShouldExit(-1)
    #~ return -1

    mkdir $env:AGENT_BUILDDIRECTORY\build
    cd $env:AGENT_BUILDDIRECTORY\build

    if ($env:imageName -eq "vs2017-win2016") {
      $env:Path += ";C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\IDE\CommonExtensions\Microsoft\CMake\CMake\bin"
    } else {
      Write-Host "Unknown image name: '$($env:imageName)'"
      $host.SetShouldExit(1)
    }

    # TODO DEBUG move this back in the TILEDB_S3 section
    # currently we do not run S3 tests on Windows because tests time out (minio+azure slow?)
    #& "$env:BUILD_SOURCESDIRECTORY\scripts\install-minio.ps1"

    $bootstrapOptions = "-EnableVerbose -EnableStaticTileDB -EnableBuildDeps"
    if ($env:TILEDB_S3 -eq "ON") {
      $bootstrapOptions = "-EnableS3 " + $bootstrapOptions
    }
    if ($env:TILEDB_AZURE -eq "ON") {
      #delay install/run of azurite until actually needed before 'make
      #check' rather than unnecessarily consuming time/resources it takes
      #since other failures may occur prior.
      #& "$env:BUILD_SOURCESDIRECTORY\scripts\install-run-azurite.ps1"
      $bootstrapOptions = "-EnableAzure " + $bootstrapOptions
    }
    if ($env:TILEDB_GCS -eq "ON") {
      $bootstrapOptions = "-EnableGCS " + $bootstrapOptions
      #NOTE: GCS simulator not yet actually in place.
    }

    $bootstrapExpression = "& $env:BUILD_SOURCESDIRECTORY\bootstrap.ps1 " + $bootstrapOptions
    Write-Host "bootstrapExpression: $bootstrapExpression"
    Invoke-Expression $bootstrapExpression

    if ($LastExitCode -ne 0) {
      Write-Host "Bootstrap failed."
      $host.SetShouldExit($LastExitCode)
    }

    cmake --build $env:AGENT_BUILDDIRECTORY\build --config Release -j $env:NUMBER_OF_PROCESSORS -- /verbosity:minimal

    if ($LastExitCode -ne 0) {
      #https://codematheus.wordpress.com/2020/01/21/yaml-error-did-not-find-expected-key-while-parsing-a-block-mapping/
      Write-Host "Build failed. CMake exit status: " $LastExitCocde
      $host.SetShouldExit($LastExitCode)
    }

    cmake --build $env:AGENT_BUILDDIRECTORY\build  -j $env:NUMBER_OF_PROCESSORS --target install-tiledb --config Release

    if ($LastExitCode -ne 0) {
      Write-Host "Installation failed."
      $host.SetShouldExit($LastExitCode)
    }
  displayName: "Build"

- powershell: |
    $env:MINIO_ACCESS_KEY = "minio"
    $env:MINIO_SECRET_KEY = "miniosecretkey"
    $env:AWS_ACCESS_KEY_ID = "minio"
    $env:AWS_SECRET_ACCESS_KEY = "miniosecretkey"

    # Clone backwards compatibility test arrays
    if ($env:BACKWARDS_COMPATIBILITY_ARRAYS -eq "ON") {
      git clone https://github.com/TileDB-Inc/TileDB-Unit-Test-Arrays.git --branch 2.2.0 $env:BUILD_SOURCESDIRECTORY/test/inputs/arrays/read_compatibility_test
    }

    if ($env:TILEDB_S3 -eq "ON") {
      # update CMake to disable S3 for the test configuration, see minio note above
      cmake -B $env:AGENT_BUILDDIRECTORY\build\tiledb -DTILEDB_S3=0 $env:AGENT_BUILDDIRECTORY\build\tiledb
    }

    # CMake exits with non-0 status if there are any warnings during the build, so
    # build the unit test executable before running tests.
    cmake --build $env:AGENT_BUILDDIRECTORY\build\tiledb  -j $env:NUMBER_OF_PROCESSORS --target tiledb_unit --config Release -- /verbosity:minimal

    #trying install of azurite with node/npm already present on machine, azurite installed earlier...
    #~ #don't need azurite running until here...
    #~ if ($env:TILEDB_AZURE -eq "ON") {
      #~ & "$env:BUILD_SOURCESDIRECTORY\scripts\install-run-azurite.ps1"
      #~ #present list of tasks to see if 'node' is running
      #~ echo "all tasks"
      #~ tasklist
      #~ echo "is 'node' present?"
      #~ tasklist | findstr /i node.exe
    #~ }

    # Actually run tests
    cmake --build $env:AGENT_BUILDDIRECTORY\build\tiledb --target check --config Release -- /verbosity:minimal

    if ($LastExitCode -ne 0) {
       Write-Host "Tests failed. CMake exit status: " $LastExitCocde
       $host.SetShouldExit($LastExitCode)
    }

    $azuriteDataPath = (Join-Path $env:TEMP "azuriteData")
    $azuriteDebugLog = (Join-Path $env:TEMP "azuriteDebugLog.Log")

    #present list of tasks to see if 'node' is running
    echo "all tasks"
    tasklist
    echo "is 'node' present?"
    tasklist | findstr /i node.exe
    Write-Host "netstat -abo (after azurite)"
    netstat -abo #'b' requires elevation, s'posed to have it
    
    Write-Host "contents of $azuriteDebugLog after --target check run..."
    c:\msys64\usr\bin\cat $azuriteDebugLog

    # Build the examples
    cmake --build $env:AGENT_BUILDDIRECTORY\build --target examples --config Release -- /verbosity:minimal

    if ($LastExitCode -ne 0) {
      Write-Host "Examples failed to build."
      $host.SetShouldExit($LastExitCode)
    }

    $env:Path += ";$env:AGENT_BUILDDIRECTORY\s\dist\bin;$env:AGENT_BUILDDIRECTORY\build\externals\install\bin"

    ls $env:AGENT_BUILDDIRECTORY\build\tiledb\examples\c_api\Release
    
    try {
      $exepath = Join-Path $env:AGENT_BUILDDIRECTORY "build\tiledb\examples\c_api\Release\quickstart_dense_c.exe"
      & $exepath
    } catch {
      Write-Host "C API example failed. Error:"
      Write-Host $_
      $host.SetShouldExit(1)
    }

    try {
      $exepath = Join-Path $env:AGENT_BUILDDIRECTORY "build\tiledb\examples\cpp_api\Release\quickstart_dense_cpp.exe"
      & $exepath
    } catch {
      Write-Host "C++ API example failed."
      $host.SetShouldExit(1)
    }

    if ($LastExitCode -ne 0) {
      Write-Host "C++ API example failed."
      $host.SetShouldExit($LastExitCode)
    }

    # Build examples
    cd $env:AGENT_BUILDDIRECTORY\s\examples\cmake_project

    mkdir build

    cd build

    # Build zip artifact
    cmake -A X64 -DCMAKE_PREFIX_PATH="$env:AGENT_BUILDDIRECTORY\s\dist" ..

    cmake --build . --config Release -- /verbosity:minimal

    .\Release\ExampleExe.exe

    .\Release\ExampleExe_static.exe

    #cd $env:AGENT_BUILDDIRECTORY

    #7z a tiledb-windows-x64.zip $env:AGENT_BUILDDIRECTORY\s\dist

  displayName: "Test"


  #- task: ArchiveFiles@2
  #  inputs:
  #    rootFolderOrFile: '$(Agent.BuildDirectory)\s\dist'
  #    includeRootFolder: false
  #    archiveType: 'zip'
  #    archiveFile: '$(Build.ArtifactStagingDirectory)/tiledb-windows-x64-$(Build.SourceVersion).zip'
  #    replaceExistingArchive: true
  #    verbose: # Optional

- powershell: |
    # tiledb_unit is configured to set a job-level variable TILEDB_CI_SUCCESS=1
    # following the test run. If this variable is not set, the build should fail.
    # see https://github.com/TileDB-Inc/TileDB/pull/1400 (5f0623f4d3)
    if ($env:TILEDB_CI_SUCCESS -ne 1) {
      Write-Host "tiledb_unit sanity-check failed! Go check logs."
      $host.SetShouldExit(1)
    }
  displayName: "Test status check"

- powershell: |
    (Get-ChildItem -Path $env:BUILD_SOURCESDIRECTORY -Include *.log -Recurse).fullname | ForEach-Object {echo $_ ---; Get-Content $_; echo ===}
  condition: failed() # only run this job if the build step failed
  displayName: "Print log files (failed build only)"

- task: PublishBuildArtifacts@1
  inputs:
    #pathtoPublish: '$(Build.ArtifactStagingDirectory)/tiledb-windows-x64-$(Build.SourceVersion).zip'
    pathtoPublish: '$(Agent.BuildDirectory)\s\dist\'
    artifactName: 'tiledb-windows-x64-$(Build.SourceVersion)'
  condition: and(succeeded(), eq(variables['imageName'], 'vs2017-win2016'))
