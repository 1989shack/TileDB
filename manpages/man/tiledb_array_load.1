.TH tiledb_array_load 1 "10 October 2015" "Version 0.1" "TileDB programs"
 
.SH NAME
tiledb_array_load - loads a collection of CSV or binary files containing cell 
values into an array

.SH SYNOPSIS
.B tiledb_array_load 
.BI "-A " "array_name " "-p " "path" 
.br
[
.BI "-w " "workspace "
] [
.BI "-g " "group "
] [
.BI "-F " "format "
] [
.BI "-l " "delimiter "
]

.SH DESCRIPTION
.B tiledb_array_load
loads a collection of CSV or binary files into an array. The user specifies in 
option \fB-p\fR the path to a single file name, or to a directory 
containing a collection of files (all of which will be loaded into
the array). Moreover, the user may indicate whether the cells in each file
are sorted along the global cell order defined in the array schema or not. This
has a dramatic effect on performance; if the cells are already sorted, then
the costly sorting operation upon loading is avoided and, hence, the load
performance is substantially improved. Note that, for the case of multiple
sorted files, loading is essentially a \fImerge\fR operation (the cells
are sorted in each file, but not necessarily across files). The user may
also specify if the files are compressed or uncompressed. Finally, the
user may specify an arbitrary delimiter in the case of CSV files. On error, 
it returns \fB-1\fR. Moreover, if it is compiled in \fBVERBOSE\fR mode, it 
prints comprehensive error messages on \fIstderr\fR. On success, it returns 
\fB0\fR. 

The following conventions apply to the \fBSYNOPSIS\fR section:

.TS
tab (@);
c lx .
\fBbold text\fR @ type exactly as shown
\fIitalic text\fR @ replace with appropriate argument
[\fB\-a \fIarg\fR]@ any or all options within [ ] are optional
.TE

\fB----- CSV file format -----\fR 

A CSV file is essentially a collection of (CSV) lines, where each line
represents an array cell. The general format of each line is of the 
following form (no spaces before and after each comma):

\fBc_1\fR , ... , \fBc_{dim_num}\fR , \fBa_1\fR , ... , \fBa_{attribute_num}\fR

where \fBc_1\fR , ... , \fBc_{dim_num}\fR are the \fBdim_num\fR
coordinates and \fBa_1\fR , ... , \fBa_{attribute_num}\fR are the 
\fBattribute_num\fR attributes.

If an attribute takes multiple values, but their number is \fIpredefined\fR in 
the array schema (e.g., \fBint32:3\fR), then these values are simply included
next to each other and separated by comma. However, if the number of values 
is \fIvariable\fR (e.g, \fBint32:var\fR), then the number of values must precede
the actual attribute values (e.g., \fB3,0.1,0.2,0.3\fR for an attribute 
\fIattr1\fR whose type was defined as \fBfloat32:var\fR means that this cell 
stores \fB3\fR values on attribute \fIattr1\fR, namely \fB0.1,0.2,0.3\fR
(more examples are provided below).

There is one exception of the above for the case of \fBstrings\fR (i.e., 
variable lengthed attributes defined as \fBchar:var\fR). These are simply given
in one CSV field (e.g., \fBabc\fR), since their number can be easily deduced
by the size of the string (the same is not true for numerics). If multiple
strings are to be included in a \fBvar:char\fR attribute, the user must
simply include an arbitrary \fIseparator\fR. For instance, one may store
strings \fBabc\fR and \fBdefg\fR as \fBabc*defg\fR. It falls upon the 
"consumer" of the data to recognize how to split the strings (TileDB simply 
stores a variable number of characters). Finally, note that,
if an attribute is defined, say, as \fBchar:3\fR (i.e., the number of
characters for this attribute per cell is known upon definition), then the
line must simply include \fBa,b,c\fR instead of \fBabc\fR (i.e., it is treated 
as in the case of the other types).

A \fBnull\fR attribute value is represented by character \fB*\fR. 

A \fBdeletion\fR of a cell in TileDB is represented by a CSV line that 
contains the coordinates of the cell to be deleted, and stores character
\fB$\fR in \fIall\fR the attribute fields.

\fBExample CSV lines\fR

Suppose that the array contains \fB2 dimensions\fR and \fB3 attributes\fR, whose
types are defined as \fBint32:2,float64:var,char:var,int64\fR (recall that the 
last type corresponds always to all coordinates collectively).
.TP
.B 1,3,10,11,2,0.1,0.2,paok 
\fB(1,3)\fR are the coordinates of the cell (of type \fBint64\fR). \fB(10,11)\fR
is the value on the \fIfirst\fR attribute (of type \fBint32\fR). \fB(0.1,0.2)\fR
is the value of the second attribute (of type \fBfloat64\fR). Finally, 
\fBpaok\fR is the value of the \fIthird\fR attribute (of type \fBchar\fR), and
my favorite soccer team in Greece :P.
.TP
.B 1,3,10,11,*,paok
Same as above, but now the second attribute value is null.
.TP
.B 1,3,$,$,$ 
Cell \fB(1,3)\fR is being deleted.

.P
\fB----- Binary file format -----\fR 

Each binary file is essentially a collection of cells in binary form,
concatenated one after the other in the file. The general format of each binary
cell is the following (all values in binary format and of the corresponding
type defined in the array schema, and '|' denotes binary concatenation):

\fBc_1\fR | ... | \fBc_{dim_num}\fR | \fBa_1\fR | ... | \fBa_{attribute_num}\fR

where \fBc_1\fR , ... , \fBc_{dim_num}\fR are the \fBdim_num\fR
coordinates and \fBa_1\fR , ... , \fBa_{attribute_num}\fR are the 
\fBattribute_num\fR attributes.

If an attribute takes multiple values, but their number is \fIpredefined\fR in 
the array schema (e.g., \fBint32:3\fR), then these values are simply 
concatenated next to each other. However, if the number of values is 
\fIvariable\fR (e.g, \fBint32:var\fR), then the number of values must precede 
the actual attribute values, and it should be of type \fBint\fR. For example,
\fB3 | 0.1 | 0.2 | 0.3\fR for an attribute \fIattr1\fR whose type was defined as
\fBfloat32:var\fR means that this cell stores \fB3\fR values on attribute 
\fIattr1\fR, namely \fB0.1,0.2,0.3\fR (more examples are provided below).
Moreover, if even a single attribute is variable-sized, the size of the
\fBentire\fR binary cell must be included immediately after the coordinates and 
before the attributes, and it must be of type \fBint32\fR. Note that the cell 
size is essentially the size of coordinates, plus the size of attributes, plus 
the size of a \fBint32\fR that holds the size value (examples below).

A \fBnull\fR attribute value is represented by the \fBmaximum\fR value in
the domain of the corresponding type. For attributes of type \fBchar\fR, null
is represented by character \fB*\fR.

A \fBdeletion\fR of a cell in TileDB is represented by a cell that 
contains the coordinates of the cell to be deleted, and stores the 
\fBmaximum-1\fR value of the corresponding type in \fIall\fR the attribute 
fields. For attributes of type \fBchar\fR, a deletion is represented by
character \fB$\fR.

.P
\fBExample binary cells\fR

Suppose that the array contains \fB2 dimensions\fR and \fB3 attributes\fR, whose
types are defined as \fBint32:3,float64,char,int64\fR (recall that the 
last type corresponds always to all coordinates collectively). Observe that this
schema essentially defines a \fBfixed size\fR for \fIall\fR cells in the array.
.TP
.B 1 | 3 | 10 | 11 | 12 | 0.1 | p 
\fB(1,3)\fR are the coordinates of the cell (of type \fBint64\fR). 
\fB(10,11,12)\fR is the value on the \fIfirst\fR attribute (of type 
\fBint32\fR). \fB0.1\fR  is the value of the \fIsecond\fR attribute (of type 
\fBfloat64\fR). Finally, \fBp\fR is the value of the \fIthird\fR attribute (of 
type \fBchar\fR).

.PP
Now suppose that the array contains \fB2 dimensions\fR and \fB3 attributes\fR as
in the previous example, but their types are now defined as
\fBint32:3,float64:var,char:var,int64\fR. This means that the cells of the array
may be of \fBvariable size\fR. Also let an \fBint\fR value consume \fI4
bytes\fR, a \fBint32\fR \fI4 bytes\fR, a \fBfloat64\fR \fI8 bytes\fR, 
a \fBchar\fR \fI1 byte\fR, and a \fBint64\fR \fI8 bytes\fR.
.TP
.B 1 | 3 | 60 | 10 | 11 | 12 | 2 | 0.1 | 0.2 | 4 | paok
\fB(1,3)\fR are the coordinates of the cell (of type \fBint64\fR). \fB60\fR
is the size in bytes of the entire cell (including even this size value itself).
\fB(10,11,12)\fR is the value on the \fIfirst\fR attribute (of type 
\fBint32\fR). \fB2\fR is the number of values for the \fIsecond\fR attribute (of
type \fBint32\fR). \fB(0.1,0.2)\fR is the values of the second attribute (of 
type \fBfloat64\fR). \fB4\fR is the number of characters in the string of the 
third attribute (of type \fBint32\fR). Finally, \fBpaok\fR is the string of the 
\fIthird\fR attribute (of type \fBchar\fR).

.P
\fB----- Physical Representation of array data -----\fR 

As explained in \fBtiledb_array_define\fR(1), every array is associated with
a directory with the same name as the array, in a particular group directory
hierarchy inside a particular workspace directory. The array directory 
contains one folder for each fragment. Upon loading data, the array
is cleared, and a new fragment is created as a folder in the array directory.

The new fragment (and its directory) is initially named after the process
that created it and a timestamp, i.e., it is in the form 
\fB"__pid_timestamp"\fR. This name will change later if the fragment takes
part in a \fBconsolidation\fR process, explained in \fBtiledb_consolidate\fR(1).
Note that during the loading operation, the fragment has name 
\fB".__pid_timestamp"\fR, so that it is hidden from potential reads that occur
simultaneously with the fragment creation. When the fragment is created 
successfully, its name changes to \fB"__pid_timestamp"\fR.

Each fragment consists of \fBdata\fR files and \fBbook-keeping\fR files.
There is one data file for each attribute (named after the attribute) and
one file for the coordinates (called \fB"__coords.tdt"\fR). All data files
have suffix \fB".tdt"\fR. The book-keeping files have suffix \fB".bkp.gz"\fR
and they are always GZIP'ed. There is one file called \fB"mbrs.bkp.gz"\fR that 
keeps the tile \fBminimum bounding rectangles (MBRs)\fR, which are useful for 
searching. File \fB"offsets.bkp.gz"\fR maintains the offsets of the tiles
in the data files. Finally, \fB"bounding_coordinates.bkp.gz"\fR keeps the
first and last coordinate of each tile, which are useful in various operations.

.SH OPTIONS
.TP
.BI "-w" " workspace" "\fR, " \fB --workspace=\fIworkspace\fR  
The path to the workspace folder where the array is defined. If it is not 
provided, the current working directory is set as the workspace by default.

.TP
.BI "-g" " group" "\fR, " \fB --group=\fIgroup\fR  
This is a directory inside the workspace where the array is defined.
Note that any group path provided is converted into an absolute path 
\fBrelative to the workspace directory\fR, i.e., regarding all home ("\\~/"), 
current ("./") and root ("/") as the workspace directory. If the group is not 
provided, the workspace is set as the default group.

.TP
.BI "-A" " array_name" "\fR, " \fB --array-name=\fIarray_name\fR  
The name of the array where the data will be loaded into. The array
must be already defined. 

.TP
.BI "-p" " path" "\fR, " \fB --path=\fIpath\fR  
The path to a CSV/binary file or to a directory of CSV/binary files. If it is
a file, then this single file will be loaded. If it is a directory,
\fBall\fR the files in the directory will be loaded. 

.TP
.BI "-F" " format" "\fR, " \fB --format=\fIformat\fR  
It can be one of the following: \fBcsv\fR (CSV format), \fBcsv.gz\fR 
(GZIP-compressed CSV format), \fBsorted.csv\fR (CSV sorted format), 
\fBsorted.csv.gz\fR (GZIP-compressed CSV sorted format), \fBbin\fR (binary 
format), \fBbin.gz\fR (GZIP-compressed binary format), \fBsorted.bin\fR (binary
sorted format), \fBsorted.bin.gz\fR (GZIP-compressed binary sorted format).
If it is not provided, then the program resolves the format by checking if
the file name contains any of the above suffices. For instance, "my_file.bin"
implies that the file is binary, whereas "my_file.csv.gz" implies that the file 
is CSV and compressed with GZIP. However, if a directory is given in option
\fB\-p\fR instead of a file, the user must explicitly define the format.
\fBNOTE:\fR All the files in a directory path must be in the \fIsame\fR format.

.TP
.BI "-l" " delimiter" "\fR, " \fB --delimiter=\fIdelimiter\fR  
This is meaningful only for CSV format. It stands for the delimiter which 
separates the values in a CSV line in the CSV file. If not given, the default is
\fB','\fR. For using a tab as a delimiter, the user must specify it simply 
as \fBtab\fR.

.SH EXAMPLES
.TP
\fBtiledb_array_load\fR \\ 
    \fB-w \fRmy_workspace/ \\
    \fB-w \fRmy_group/ \\
    \fB-A \fRmy_array \\
    \fB-p \fRmy_array.csv

This loads into array \fImy_array\fR, defined in folder 
\fImy_workspace/my_group/my_array\fR, the data stored in the CSV file 
\fImy_array.csv\fR. It is derived that the cells are unsorted.

.TP
\fBtiledb_array_load\fR \\ 
    \fB-w \fRmy_workspace/ \\
    \fB-w \fRmy_group/ \\
    \fB-A \fRmy_array \\
    \fB-l \fRtab \\
    \fB-p \fRmy_csv_files/

This is the same as the first example, but now all the files included in
directory \fImy_csv_files/\fR will be loaded into the array. Also \fBtab\fR
is used as a delimiter in the CSV files.

.TP
\fBtiledb_array_load\fR \\ 
    \fB-w \fRmy_workspace/ \\
    \fB-A \fRmy_array \\
    \fB-p \fRmy_file \\
    \fB-F \fRsorted.bin.gz

This loads into array \fImy_array\fR, defined in folder 
\fImy_workspace/my_array\fR, the data stored in the GZIP'ed 
binary file \fImy_array\fR. The cells in this file are sorted.

.TP
\fBtiledb_array_load\fR \\ 
    \fB-w \fRmy_workspace/ \\
    \fB-A \fRmy_array \\
    \fB-p \fRmy_file.sorted.bin.gz 

Exactly the same as the previous example. The format is derived by the file 
name instead of the \fB\-F\fR option.

.SH EXIT STATUS
.TP 
\fB0\fR for success and \fB-1\fR for error.

.SH SEE ALSO
.BR "tiledb_array_define" "(1), " "tiledb_array_export" "(1) " \
"tiledb_dataset_generate" "(1) "

.SH AUTHOR
Stavros Papadopoulos <http://people.csail.mit.edu/stavrosp>, Copyright (c) 2015
